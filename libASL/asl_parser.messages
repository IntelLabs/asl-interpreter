declarations_start: WHILE
##
## Ends in an error in state: 238.
##
## declarations_start' -> . declarations_start [ # ]
##
## The known suffix of the stack is as follows:
##
##

A top level declaration was expected at this point.

declarations_start: VAR WHILE
##
## Ends in an error in state: 239.
##
## variable_declaration -> VAR . ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## VAR
##

A variable name such as 'x' was expected at this point.

declarations_start: VAR ID WHILE
##
## Ends in an error in state: 240.
##
## variable_declaration -> VAR ident . COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## VAR ident
##

A type annotation such as ': bits(32);' was expected at this point.

declarations_start: VAR ID COLON WHILE
##
## Ends in an error in state: 241.
##
## variable_declaration -> VAR ident COLON . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## VAR ident COLON
##

A type such as 'bits(32);' was expected at this point.


expr_command_start: ID AS TYPEOF WHILE
##
## Ends in an error in state: 6.
##
## ty -> TYPEOF . LPAREN expr RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## TYPEOF
##

    "(" expected in typeof terms.
The syntax of typeof is
    "typeof ( <expression> )"

expr_command_start: ID AS TYPEOF LPAREN WHILE
##
## Ends in an error in state: 7.
##
## ty -> TYPEOF LPAREN . expr RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## TYPEOF LPAREN
##

Malformed typeof term.
The syntax of typeof is
    "typeof ( <expression> )"

expr_command_start: UNKNOWN WHILE
##
## Ends in an error in state: 4.
##
## aexpr -> UNKNOWN . COLON ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## UNKNOWN
##

Malformed UNKNOWN expression.
The syntax of UNKNOWN expressions is
    "UNKNOWN : <type>"

expr_command_start: UNKNOWN COLON WHILE
##
## Ends in an error in state: 5.
##
## aexpr -> UNKNOWN COLON . ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## UNKNOWN COLON
##

Malformed UNKNOWN expression.
The syntax of UNKNOWN expressions is
    "UNKNOWN : <type>"

expr_command_start: ID AS LPAREN WHILE
##
## Ends in an error in state: 11.
##
## ty -> LPAREN . loption(separated_nonempty_list(COMMA,ty)) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Malformed tuple type (or spurious parentheses).
The syntax of tuple types is
    "( <type1>, <type2>, ... )"

expr_command_start: ID AS INTEGER WHILE
##
## Ends in an error in state: 12.
##
## ty -> INTEGER . constraint_opt [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## INTEGER
##

Malformed integer type.
The syntax of integer types is
    "integer"
or
    "integer { <constraint_ranges> }"

expr_command_start: ID AS LBRACE WHILE
##
## Ends in an error in state: 13.
##
## constraints -> LBRACE . separated_nonempty_list(COMMA,constraint_range) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Malformed integer constraint.
The syntax of integer constraints is
    "{ <constraint_ranges> }"

expr_command_start: UNDERSCORE_UNDERSCORE_LET WHILE
##
## Ends in an error in state: 8.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET . ident COLON ty EQ expr UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET
##

Missing identifier in (unofficial extension) expression-let.
The syntax of expression-lets is
    "__let <variable identifier> : <type> = <expression> __in <expression>"

expr_command_start: UNDERSCORE_UNDERSCORE_LET ID WHILE
##
## Ends in an error in state: 9.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET ident . COLON ty EQ expr UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET ident
##

Malformed expression-let (unofficial extension).
The syntax of expression-lets is
    "__let $0 : <type> = <expression> __in <expression>"

expr_command_start: UNDERSCORE_UNDERSCORE_LET ID COLON WHILE
##
## Ends in an error in state: 10.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET ident COLON . ty EQ expr UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET ident COLON
##

Malformed expression-let (unofficial extension).
The syntax of expression-lets is
    "__let $1 : <type> = <expression> __in <expression>"

expr_command_start: ID AS BITS WHILE
##
## Ends in an error in state: 92.
##
## ty -> BITS . LPAREN expr RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## ty -> BITS . LPAREN expr RPAREN LBRACE regfields RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## BITS
##

Missing size in bitvector type.
The syntax of bitvector types is
    "bits(<expression>)"


expr_command_start: ID AS BITS LPAREN WHILE
##
## Ends in an error in state: 93.
##
## ty -> BITS LPAREN . expr RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## ty -> BITS LPAREN . expr RPAREN LBRACE regfields RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## BITS LPAREN
##

Missing size in bitvector type.
The syntax of bitvector types is
    "bits(<expression>)"


expr_command_start: LPAREN WHILE
##
## Ends in an error in state: 21.
##
## aexpr -> LPAREN . expr RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> LPAREN . separated_nonempty2_list(COMMA,expr) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Malformed parenthesized expression or tuple expression.
The syntax of parenthesized expressions and tuples is
    "(<expression>)"
or
    "(<expression1>, <expression2>, ...)"

expr_command_start: LBRACK WHILE
##
## Ends in an error in state: 22.
##
## aexpr -> LBRACK . separated_nonempty2_list(COMMA,expr) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Malformed bitvector concatenation.
The syntax of bitvector concatenations is
    "[<expression1>, <expression2>, ...]"

expr_command_start: ID AS ARRAY WHILE
##
## Ends in an error in state: 109.
##
## ty -> ARRAY . LBRACK ixtype RBRACK OF ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY
##

Malformed array type.
The syntax of array types is
    "array [ <expression> ] of <type>"
or
    "array [ <enumeration type name> ] of <type>"

expr_command_start: ID AS ARRAY LBRACK WHILE
##
## Ends in an error in state: 110.
##
## ty -> ARRAY LBRACK . ixtype RBRACK OF ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY LBRACK
##

Malformed array type.
The syntax of array types is
    "array [ <expression> ] of <type>"
or
    "array <enumeration type name> of <type>"

expr_command_start: IF WHILE
##
## Ends in an error in state: 24.
##
## conditional_expression -> IF . cexpr THEN expr list(e_elsif) ELSE expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> else <expression>"
or
    "if <expression> then <expression> elsif ... else <expression>"


expr_command_start: ARRAY WHILE
##
## Ends in an error in state: 27.
##
## aexpr -> ARRAY . LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY
##

Malformed array expression (unofficial extension).
The syntax of array expressions is
    "array(<list of expressions>)"

expr_command_start: ARRAY LPAREN WHILE
##
## Ends in an error in state: 28.
##
## aexpr -> ARRAY LPAREN . separated_nonempty_list(COMMA,expr) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY LPAREN
##

Malformed array expression (unofficial extension).
The syntax of array expressions is
    "array(<list of expressions>)"


expr_command_start: BANG WHILE
##
## Ends in an error in state: 29.
##
## bexpr -> unop . fexpr [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## unop
##

Malformed unary expression.
The syntax of unary expressions is
    "$0 <expression>"

expr_command_start: ID WHILE
##
## Ends in an error in state: 32.
##
## aexpr -> ident . [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN throws [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . QUERY LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed expression.
The syntax of expressions that start with an identifier is
    "$0"                                      - variable read or call getter function
or
    "$0(<expressions>)"                       - function call
or
    "$0{<field assignments>}"                 - record expression
or
    "$0(<expressions>){<field assignments>}"  - record expression

expr_command_start: ID LPAREN WHILE
##
## Ends in an error in state: 39.
##
## aexpr -> ident LPAREN . loption(separated_nonempty_list(COMMA,arg)) RPAREN throws [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident LPAREN . loption(separated_nonempty_list(COMMA,arg)) RPAREN LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident LPAREN
##

Malformed expression.
The syntax of expressions that start with an identifier is
    "$0"                                      - variable read or call getter function
or
    "$0(<expressions>)"                       - function call
or
    "$0{<field assignments>}"                 - record expression
or
    "$0(<expressions>){<field assignments>}"  - record expression


expr_command_start: ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 41.
##
## aexpr -> ident LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN . throws [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN . LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN
##

Malformed expression.
The syntax of expressions that start with an identifier is
    "$0"                                      - variable read or call getter function
or
    "$0(<expressions>)"                       - function call
or
    "$0{<field assignments>}"                 - record expression
or
    "$0(<expressions>){<field assignments>}"  - record expression

expr_command_start: ID LPAREN RPAREN LBRACE WHILE
##
## Ends in an error in state: 43.
##
## aexpr -> ident LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN LBRACE . separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN LBRACE
##

Malformed record expression.
The syntax of record expressions is
    "$0{<field assignments>}"                 - record expression
or
    "$0(<expressions>){<field assignments>}"  - record expression


expr_command_start: ID LBRACE ID WHILE
##
## Ends in an error in state: 46.
##
## field_assignment -> ident . EQ expr [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed field assignment in record expression.
The syntax of field assignments is
    "$0 = <expression>"

expr_command_start: ID LBRACE ID EQ WHILE
##
## Ends in an error in state: 47.
##
## field_assignment -> ident EQ . expr [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ident EQ
##

Malformed field assignment in record expression.
The syntax of field assignments is
    "$1 = <expression>"

expr_command_start: ID DOT ID WHILE
##
## Ends in an error in state: 48.
##
## bexpr -> fexpr . [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . DOT ident [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . DOT LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . LBRACK loption(separated_nonempty_list(COMMA,slice)) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . IN pattern [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## fexpr
##

Malformed expression.
The most likely expression syntax is
    "$0;"
    "$0.<field identifier>"
    "$0.[<field identifier list>]"
    "$0 IN <pattern>"

expr_command_start: ID LBRACK WHILE
##
## Ends in an error in state: 49.
##
## fexpr -> fexpr LBRACK . loption(separated_nonempty_list(COMMA,slice)) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## fexpr LBRACK
##

Malformed bitslice expression.
The syntax of bitslice expressions is
    "$1[<slice list>]"

expr_command_start: ID LBRACK ID COLON ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 50.
##
## separated_nonempty_list(COMMA,slice) -> slice . [ RBRACK ]
## separated_nonempty_list(COMMA,slice) -> slice . COMMA separated_nonempty_list(COMMA,slice) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## slice
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 135, spurious reduction of production slice -> expr COLON expr
##

Malformed slice list.
The syntax of slice lists is
    "$0, <slice1>"
or
    "$0, <slice1>, <slice2>"
or
    "$0, <slice1>, <slice2>, ..."

expr_command_start: ID LBRACK ID COMMA WHILE
##
## Ends in an error in state: 51.
##
## separated_nonempty_list(COMMA,slice) -> slice COMMA . separated_nonempty_list(COMMA,slice) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## slice COMMA
##

Malformed slice list.
The syntax of slice lists is
    "$1, <slice1>"
or
    "$1, <slice1>, <slice2>"
or
    "$1, <slice1>, <slice2>, ..."

expr_command_start: ID LBRACK ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 53.
##
## slice -> expr . [ RBRACK COMMA ]
## slice -> expr . COLON expr [ RBRACK COMMA ]
## slice -> expr . PLUS_COLON expr [ RBRACK COMMA ]
## slice -> expr . STAR_COLON expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed slice.
The syntax of slices is
    "$0"
or
    "$0 : <expression>"
or
    "$0 +: <expression>"
or
    "$0 *: <expression>"

expr_command_start: ID LBRACK ID STAR_COLON WHILE
##
## Ends in an error in state: 54.
##
## slice -> expr STAR_COLON . expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## expr STAR_COLON
##

Malformed element slice.
The syntax of element slices is
    "$0 *: <expression>"

expr_command_start: ID AMPERSAND_AMPERSAND WHILE
##
## Ends in an error in state: 88.
##
## factor -> binop . bexpr [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## binop
##

Error in binary expression.
The syntax of binary expressions is
    "<expression> $0 <expression>"

expr_command_start: BITSLIT EQ
##
## Ends in an error in state: 90.
##
## aexpr -> aexpr . AS constraints [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> aexpr . AS ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## fexpr -> aexpr . [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## aexpr
##

Malformed expression.


expr_command_start: ID AS WHILE
##
## Ends in an error in state: 91.
##
## aexpr -> aexpr AS . constraints [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> aexpr AS . ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## aexpr AS
##

Error in checked type expression.
The syntax of checked type expressions is
    "$1 as { <constraint range list> }"
or
    "$1 as <type>"

expr_command_start: ID AS ID WHILE
##
## Ends in an error in state: 115.
##
## ty -> ident . [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## ty -> ident . LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident
##

Error in type.
The expected syntax is
    "<type identifier>"
or
    "<type identifier> ( <expression>, ... <expression> )"

expr_command_start: ID AS ID LPAREN WHILE
##
## Ends in an error in state: 116.
##
## ty -> ident LPAREN . separated_nonempty_list(COMMA,expr) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident LPAREN
##

Error in parameterized type invocation.
The expected syntax is
    "<type identifier> ( <expression>, ... <expression> )"

expr_command_start: ID LPAREN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 38.
##
## aexpr -> ident . [ XOR STAR SLASH RPAREN REM QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV COMMA CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN throws [ XOR STAR SLASH RPAREN REM QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV COMMA CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . QUERY LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN [ XOR STAR SLASH RPAREN REM QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV COMMA CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR STAR SLASH RPAREN REM QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV COMMA CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR STAR SLASH RPAREN REM QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV COMMA CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## separated_nonempty_list(COMMA,arg) -> ident . EQ expr [ RPAREN ]
## separated_nonempty_list(COMMA,arg) -> ident . EQ expr COMMA separated_nonempty_list(COMMA,arg) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## ident
##

Error in expression list.
The expected syntax is
    "$0" (followed by ")")
or
    "$0, <expression> ..."


expr_command_start: ID LPAREN ID COMMA WHILE
##
## Ends in an error in state: 176.
##
## separated_nonempty_list(COMMA,arg) -> expr COMMA . separated_nonempty_list(COMMA,arg) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Error in expression list.
The expected syntax is
    "$1, <expression> ..."


expr_command_start: ID LBRACK ID PLUS_COLON WHILE
##
## Ends in an error in state: 132.
##
## slice -> expr PLUS_COLON . expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## expr PLUS_COLON
##

Malformed sized slice.
The syntax of sized slices is
    "$1 +: <expression>"


expr_command_start: ID LBRACK ID COLON WHILE
##
## Ends in an error in state: 134.
##
## slice -> expr COLON . expr [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## expr COLON
##

Malformed slice.
The syntax of slices is
    "$1 : <expression>"

expr_command_start: ID IN WHILE
##
## Ends in an error in state: 139.
##
## fexpr -> fexpr IN . pattern [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## fexpr IN
##

Malformed pattern match expression.
The syntax of pattern match expressions is
    "$1 IN <pattern>"

expr_command_start: ID IN LPAREN WHILE
##
## Ends in an error in state: 143.
##
## pattern -> LPAREN . separated_nonempty2_list(COMMA,pattern) RPAREN [ XOR WHERE UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Malformed tuple pattern.
The syntax of tuple patterns is 
    "(<pattern>, ... <pattern>)"

expr_command_start: ID IN LBRACE WHILE
##
## Ends in an error in state: 144.
##
## pattern -> LBRACE . loption(separated_nonempty_list(COMMA,apattern)) RBRACE [ XOR WHERE UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Malformed set pattern.
The syntax of set patterns is
    "{ <pattern>, ... <pattern> }"

expr_command_start: ID IN LBRACE ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 148.
##
## apattern -> expr . DOT_DOT expr [ RBRACE COMMA ]
## apattern -> expr . [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed atomic pattern.
The syntax of atomic patterns is
    "$0"
or
    "$0 .. <expression>"

expr_command_start: ID IN LBRACE ID DOT_DOT WHILE
##
## Ends in an error in state: 149.
##
## apattern -> expr DOT_DOT . expr [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## expr DOT_DOT
##

Malformed range pattern.
The syntax of range patterns is
    "$1 .. <expression>"

expr_command_start: ID IN LBRACE ID DOT_DOT ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 151.
##
## separated_nonempty_list(COMMA,apattern) -> apattern . [ RBRACE ]
## separated_nonempty_list(COMMA,apattern) -> apattern . COMMA separated_nonempty_list(COMMA,apattern) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## apattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 150, spurious reduction of production apattern -> expr DOT_DOT expr
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"

expr_command_start: ID IN LBRACE ID COMMA WHILE
##
## Ends in an error in state: 152.
##
## separated_nonempty_list(COMMA,apattern) -> apattern COMMA . separated_nonempty_list(COMMA,apattern) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## apattern COMMA
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"

expr_command_start: ID IN LPAREN ID WHILE
##
## Ends in an error in state: 158.
##
## separated_nonempty2_list(COMMA,pattern) -> pattern . COMMA pattern [ RPAREN ]
## separated_nonempty2_list(COMMA,pattern) -> pattern . COMMA separated_nonempty2_list(COMMA,pattern) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## pattern
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"



expr_command_start: ID IN LPAREN ID COMMA WHILE
##
## Ends in an error in state: 159.
##
## separated_nonempty2_list(COMMA,pattern) -> pattern COMMA . pattern [ RPAREN ]
## separated_nonempty2_list(COMMA,pattern) -> pattern COMMA . separated_nonempty2_list(COMMA,pattern) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"


expr_command_start: ID IN LPAREN ID COMMA ID WHILE
##
## Ends in an error in state: 161.
##
## separated_nonempty2_list(COMMA,pattern) -> pattern . COMMA pattern [ RPAREN ]
## separated_nonempty2_list(COMMA,pattern) -> pattern COMMA pattern . [ RPAREN ]
## separated_nonempty2_list(COMMA,pattern) -> pattern . COMMA separated_nonempty2_list(COMMA,pattern) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## pattern COMMA pattern
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"

expr_command_start: ID DOT WHILE
##
## Ends in an error in state: 164.
##
## fexpr -> fexpr DOT . ident [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr DOT . LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## fexpr DOT
##

Malformed field access.
The syntax of field accesses is
    "$1 . <field identifier>"
or
    "$1 . [ <list of field identifiers> ]"

expr_command_start: ID DOT LBRACK WHILE
##
## Ends in an error in state: 165.
##
## fexpr -> fexpr DOT LBRACK . separated_nonempty_list(COMMA,ident) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## fexpr DOT LBRACK
##

Malformed concatenated field access.
The syntax of concatenated field accesses is
    "$1 . [ <list of field identifiers> ]"

expr_command_start: ID DOT LBRACK ID SEMICOLON
##
## Ends in an error in state: 166.
##
## fexpr -> fexpr DOT LBRACK separated_nonempty_list(COMMA,ident) . RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## fexpr DOT LBRACK separated_nonempty_list(COMMA,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
##

Malformed concatenated field access.
The syntax of concatenated field accesses is
    "$1 . [ <list of field identifiers> ]"


declarations_start: ENUMERATION ID LBRACE ID WHILE
##
## Ends in an error in state: 168.
##
## separated_nonempty_list(COMMA,ident) -> ident . [ SEMICOLON RPAREN RBRACK RBRACE COLON ]
## separated_nonempty_list(COMMA,ident) -> ident . COMMA separated_nonempty_list(COMMA,ident) [ SEMICOLON RPAREN RBRACK RBRACE COLON ]
##
## The known suffix of the stack is as follows:
## ident
##

A list of identifiers such as "RED, GREEN, BLUE" or "x, y"
was expected at this point.

declarations_start: ENUMERATION ID LBRACE ID COMMA WHILE
##
## Ends in an error in state: 169.
##
## separated_nonempty_list(COMMA,ident) -> ident COMMA . separated_nonempty_list(COMMA,ident) [ SEMICOLON RPAREN RBRACK RBRACE COLON ]
##
## The known suffix of the stack is as follows:
## ident COMMA
##

A list of identifiers such as "RED, GREEN, BLUE" or "x, y"
was expected at this point.


expr_command_start: ID LBRACE ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 126.
##
## separated_nonempty_list(COMMA,field_assignment) -> field_assignment . [ RBRACE ]
## separated_nonempty_list(COMMA,field_assignment) -> field_assignment . COMMA separated_nonempty_list(COMMA,field_assignment) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 172, spurious reduction of production field_assignment -> ident EQ expr
##

Malformed field assignment list.
The syntax of field assignment lists is
    "$0" followed by "}"
or
    "$0, <field identifier> = <expression>"
or
    "$0, <field identifier> = <expression>, ..."

expr_command_start: ID LBRACE ID EQ ID COMMA WHILE
##
## Ends in an error in state: 127.
##
## separated_nonempty_list(COMMA,field_assignment) -> field_assignment COMMA . separated_nonempty_list(COMMA,field_assignment) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment COMMA
##

Malformed field assignment list.
The syntax of field assignment lists is
    "$1, <field identifier> = <expression>"
or
    "$1, <field identifier> = <expression>, ..."

expr_command_start: ID LBRACE WHILE
##
## Ends in an error in state: 123.
##
## aexpr -> ident LBRACE . separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident LBRACE
##

Malformed record expression.
The syntax of record expressions is
    "<type identifier> { <field assignment list> }"
or
    "<type identifier>( <type parameter list> ) { <field assignment list> }"

expr_command_start: BANG ID DOT ID WHILE
##
## Ends in an error in state: 182.
##
## bexpr -> unop fexpr . [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . DOT ident [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . DOT LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . LBRACK loption(separated_nonempty_list(COMMA,slice)) RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
## fexpr -> fexpr . IN pattern [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## unop fexpr
##

Malformed expression.

expr_command_start: IF ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 185.
##
## conditional_expression -> IF cexpr . THEN expr list(e_elsif) ELSE expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF cexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> else <expression>"
or
    "if <expression> then <expression> elsif ... else <expression>"


expr_command_start: IF ID THEN WHILE
##
## Ends in an error in state: 186.
##
## conditional_expression -> IF cexpr THEN . expr list(e_elsif) ELSE expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF cexpr THEN
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if $1 then <expression> else <expression>"
or
    "if $1 then <expression> elsif ... else <expression>"

expr_command_start: IF ID THEN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 187.
##
## conditional_expression -> IF cexpr THEN expr . list(e_elsif) ELSE expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF cexpr THEN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if $2 then <expression> else <expression>"
or
    "if $2 then <expression> elsif ... else <expression>"

expr_command_start: IF ID THEN ID ELSIF WHILE
##
## Ends in an error in state: 188.
##
## e_elsif -> ELSIF . expr THEN expr [ ELSIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSIF
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> elsif <expression> then <expression> ... else <expression>"


expr_command_start: IF ID THEN ID ELSIF ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 189.
##
## e_elsif -> ELSIF expr . THEN expr [ ELSIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSIF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> elsif <expression> then <expression> ... else <expression>"

expr_command_start: IF ID THEN ID ELSIF ID THEN WHILE
##
## Ends in an error in state: 190.
##
## e_elsif -> ELSIF expr THEN . expr [ ELSIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSIF expr THEN
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> elsif <expression> then <expression> ... else <expression>"

expr_command_start: IF ID THEN ID ELSE WHILE
##
## Ends in an error in state: 193.
##
## conditional_expression -> IF cexpr THEN expr list(e_elsif) ELSE . expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF cexpr THEN expr list(e_elsif) ELSE
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> else <expression>"
or
    "if <expression> then <expression> elsif <expression> then <expression> ... else <expression>"


expr_command_start: IF ID THEN ID ELSIF ID THEN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 195.
##
## list(e_elsif) -> e_elsif . list(e_elsif) [ ELSE ]
##
## The known suffix of the stack is as follows:
## e_elsif
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 191, spurious reduction of production e_elsif -> ELSIF expr THEN expr
##

Malformed conditional expression.
The syntax of conditional expressions is
    "if <expression> then <expression> elsif <expression> then <expression> ... else <expression>"

expr_command_start: ID AS ARRAY LBRACK BITSLIT UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 111.
##
## ty -> ARRAY LBRACK ixtype . RBRACK OF ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY LBRACK ixtype
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 129, spurious reduction of production ixtype -> expr
##

Missing "]" in array type.
The syntax of array types is
    "array [ <expression> ] of <type>"
or
    "array [ <enumeration type name> ] of <type>"

expr_command_start: ID AS ARRAY LBRACK BITSLIT RBRACK WHILE
##
## Ends in an error in state: 112.
##
## ty -> ARRAY LBRACK ixtype RBRACK . OF ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY LBRACK ixtype RBRACK
##

Missing "]" in array type.
The syntax of array types is
    "array [ <expression> ] of <type>"
or
    "array [ <enumeration type name> ] of <type>"

expr_command_start: ID AS ARRAY LBRACK BITSLIT RBRACK OF WHILE
##
## Ends in an error in state: 113.
##
## ty -> ARRAY LBRACK ixtype RBRACK OF . ty [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ARRAY LBRACK ixtype RBRACK OF
##

Missing "of" in array type.
The syntax of array types is
    "array [ $2 ] of <type>"

expr_command_start: ID AS ARRAY LBRACK ID WHILE
##
## Ends in an error in state: 122.
##
## aexpr -> ident . [ XOR STAR SLASH REM RBRACK QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN throws [ XOR STAR SLASH REM RBRACK QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . QUERY LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN [ XOR STAR SLASH REM RBRACK QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR STAR SLASH REM RBRACK QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## aexpr -> ident . LBRACE separated_nonempty_list(COMMA,field_assignment) RBRACE [ XOR STAR SLASH REM RBRACK QUOT PLUS_PLUS PLUS OR MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_EQ DOT DIVRM DIV CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## ixtype -> ident . [ RBRACK ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed expression starting with identifier.
The syntax of expressions that start with an identifier is
    "$0"                                      - variable read or call getter function
or
    "$0(<expressions>)"                       - function call
or
    "$0{<field assignments>}"                 - record expression
or
    "$0(<expressions>){<field assignments>}"  - record expression

expr_command_start: LBRACK ID COMMA ID RPAREN
##
## Ends in an error in state: 197.
##
## aexpr -> LBRACK separated_nonempty2_list(COMMA,expr) . RBRACK [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LBRACK separated_nonempty2_list(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 202, spurious reduction of production separated_nonempty2_list(COMMA,expr) -> expr COMMA expr
##

Malformed bitvector concatenation.
The syntax of bitvector concatenations is
    "[<expression1>, <expression2>, ...]"

expr_command_start: LBRACK ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 199.
##
## separated_nonempty2_list(COMMA,expr) -> expr . COMMA expr [ RBRACK ]
## separated_nonempty2_list(COMMA,expr) -> expr . COMMA separated_nonempty2_list(COMMA,expr) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed bitvector concatenation.
The syntax of bitvector concatenations is
    "[<expression1>, <expression2>, ...]"


expr_command_start: LBRACK ID COMMA WHILE
##
## Ends in an error in state: 200.
##
## separated_nonempty2_list(COMMA,expr) -> expr COMMA . expr [ RPAREN RBRACK ]
## separated_nonempty2_list(COMMA,expr) -> expr COMMA . separated_nonempty2_list(COMMA,expr) [ RPAREN RBRACK ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Malformed expression list.
The syntax of expression lists is
    "<expression1>, <expression2>, ..."


expr_command_start: LBRACK ID COMMA ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 202.
##
## separated_nonempty2_list(COMMA,expr) -> expr . COMMA expr [ RPAREN RBRACK ]
## separated_nonempty2_list(COMMA,expr) -> expr COMMA expr . [ RPAREN RBRACK ]
## separated_nonempty2_list(COMMA,expr) -> expr . COMMA separated_nonempty2_list(COMMA,expr) [ RPAREN RBRACK ]
##
## The known suffix of the stack is as follows:
## expr COMMA expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed expression list.
The syntax of expression lists is
    "<expression1>, <expression2>, ..."


expr_command_start: LPAREN ID COMMA ID RBRACK
##
## Ends in an error in state: 203.
##
## aexpr -> LPAREN separated_nonempty2_list(COMMA,expr) . RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## LPAREN separated_nonempty2_list(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 202, spurious reduction of production separated_nonempty2_list(COMMA,expr) -> expr COMMA expr
##

Malformed tuple.
The syntax of tuples is
    "( <expression1>, <expression2>, ... )"


expr_command_start: LPAREN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 205.
##
## aexpr -> LPAREN expr . RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## separated_nonempty2_list(COMMA,expr) -> expr . COMMA expr [ RPAREN ]
## separated_nonempty2_list(COMMA,expr) -> expr . COMMA separated_nonempty2_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## LPAREN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed expression list.
The syntax of expression lists is
    "<expression1>, <expression2>, ..."


expr_command_start: ID AS BITS LPAREN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 94.
##
## ty -> BITS LPAREN expr . RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## ty -> BITS LPAREN expr . RPAREN LBRACE regfields RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## BITS LPAREN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ")" in bitvector type.
The syntax of bitvector types is
    "bits($0)"


expr_command_start: ID AS BITS LPAREN ID RPAREN WHILE
##
## Ends in an error in state: 95.
##
## ty -> BITS LPAREN expr RPAREN . [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
## ty -> BITS LPAREN expr RPAREN . LBRACE regfields RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## BITS LPAREN expr RPAREN
##

Malformed bitvector type.
The syntax of bitvector types is
    "bits(<expression>)"
or
    "bits(<expression>){ <register fields> }"

expr_command_start: ID AS BITS LPAREN ID RPAREN LBRACE WHILE
##
## Ends in an error in state: 96.
##
## ty -> BITS LPAREN expr RPAREN LBRACE . regfields RBRACE [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## BITS LPAREN expr RPAREN LBRACE
##


Malformed bitvector type.
The syntax of bitvector types is
    "bits(<expression>)"
or
    "bits(<expression>){ [<slice list>] <field identifier>, ... }"


expr_command_start: ID AS BITS LPAREN ID RPAREN LBRACE LBRACK WHILE
##
## Ends in an error in state: 97.
##
## regfield -> LBRACK . separated_nonempty_list(COMMA,slice) RBRACK ident [ RBRACE LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Malformed register field.
The syntax of register fields is
    "[<slice list>] <field identifier>"

expr_command_start: ID AS BITS LPAREN ID RPAREN LBRACE LBRACK ID RBRACK WHILE
##
## Ends in an error in state: 99.
##
## regfield -> LBRACK separated_nonempty_list(COMMA,slice) RBRACK . ident [ RBRACE LBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACK separated_nonempty_list(COMMA,slice) RBRACK
##

Malformed register field.
The syntax of register fields is
    "[$1] <field identifier>"

expr_command_start: ID AS BITS LPAREN ID RPAREN LBRACE LBRACK ID RBRACK ID WHILE
##
## Ends in an error in state: 103.
##
## list(regfield) -> regfield . list(regfield) [ RBRACE ]
## regfields -> regfield . COMMA regfields [ RBRACE ]
##
## The known suffix of the stack is as follows:
## regfield
##

Malformed register field list.
The syntax of register field lists is
    "{ [<slice list>] <field identifier>, ... [<slice list>] <field identifier> }"

expr_command_start: ID AS BITS LPAREN ID RPAREN LBRACE LBRACK ID RBRACK ID COMMA WHILE
##
## Ends in an error in state: 104.
##
## regfields -> regfield COMMA . regfields [ RBRACE ]
##
## The known suffix of the stack is as follows:
## regfield COMMA
##

Malformed register field.
The syntax of register field lists is
    "{ [<slice list>] <field identifier>, ... [<slice list>] <field identifier> }"

expr_command_start: ID AS BITS LPAREN ID RPAREN LBRACE LBRACK ID RBRACK ID LBRACK ID RBRACK ID WHILE
##
## Ends in an error in state: 107.
##
## list(regfield) -> regfield . list(regfield) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## regfield
##

Malformed register field list.
The syntax of register field lists is
    "{ [<slice list>] <field identifier>, ... [<slice list>] <field identifier> }"

expr_command_start: UNDERSCORE_UNDERSCORE_LET ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 226.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET ident COLON ty . EQ expr UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing initializer in (unofficial extension) expression-let.
The syntax of expression-lets is
    "__let <variable identifier> : <type> = <expression> __in <expression>"

expr_command_start: UNDERSCORE_UNDERSCORE_LET ID COLON INTEGER EQ WHILE
##
## Ends in an error in state: 227.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET ident COLON ty EQ . expr UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET ident COLON ty EQ
##

Missing initializer in (unofficial extension) expression-let.
The syntax of expression-lets is
    "__let <variable identifier> : <type> = <expression> __in <expression>"

expr_command_start: UNDERSCORE_UNDERSCORE_LET ID COLON INTEGER EQ ID TO
##
## Ends in an error in state: 228.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET ident COLON ty EQ expr . UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET ident COLON ty EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing "__in" in (unofficial extension) expression-let.
The syntax of expression-lets is
    "__let <variable identifier> : <type> = <expression> __in <expression>"

expr_command_start: UNDERSCORE_UNDERSCORE_LET ID COLON INTEGER EQ ID UNDERSCORE_UNDERSCORE_IN WHILE
##
## Ends in an error in state: 229.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_LET ident COLON ty EQ expr UNDERSCORE_UNDERSCORE_IN . expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_LET ident COLON ty EQ expr UNDERSCORE_UNDERSCORE_IN
##

Malformed (unofficial extension) expression-let.
The syntax of expression-lets is
    "__let <variable identifier> : <type> = <expression> __in <expression>"

expr_command_start: ID AS LBRACE ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 212.
##
## constraint_range -> expr . [ RBRACE COMMA ]
## constraint_range -> expr . DOT_DOT expr [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed integer constraint.
The syntax of integer constraints is
    "{ <constraint>, ... <constraint> }"
and the syntax of a constraint is
    "<expression>"
or
    "<expression> .. <expression>"

expr_command_start: ID AS LBRACE ID DOT_DOT WHILE
##
## Ends in an error in state: 213.
##
## constraint_range -> expr DOT_DOT . expr [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## expr DOT_DOT
##

Malformed integer constraint.
The syntax of integer constraints is
    "{ <constraint>, ... <constraint> }"
and the syntax of a constraint is
    "<expression>"
or
    "<expression> .. <expression>"

expr_command_start: ID AS LBRACE ID DOT_DOT ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 215.
##
## separated_nonempty_list(COMMA,constraint_range) -> constraint_range . [ RBRACE ]
## separated_nonempty_list(COMMA,constraint_range) -> constraint_range . COMMA separated_nonempty_list(COMMA,constraint_range) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## constraint_range
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 214, spurious reduction of production constraint_range -> expr DOT_DOT expr
##

Malformed integer constraint.
The syntax of integer constraints is
    "{ <constraint>, ... <constraint> }"
and the syntax of a constraint is
    "<expression>"
or
    "<expression> .. <expression>"

expr_command_start: ID AS LBRACE ID COMMA WHILE
##
## Ends in an error in state: 216.
##
## separated_nonempty_list(COMMA,constraint_range) -> constraint_range COMMA . separated_nonempty_list(COMMA,constraint_range) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## constraint_range COMMA
##

Malformed integer constraint.
The syntax of integer constraints is
    "{ <constraint>, ... <constraint> }"
and the syntax of a constraint is
    "<expression>"
or
    "<expression> .. <expression>"

expr_command_start: ID AS LPAREN INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 220.
##
## separated_nonempty_list(COMMA,ty) -> ty . [ RPAREN ]
## separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Malformed type list.
The syntax of type lists is
    "( <type>, ... <type> )"

expr_command_start: ID AS LPAREN INTEGER COMMA WHILE
##
## Ends in an error in state: 221.
##
## separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## ty COMMA
##

Malformed type list.
The syntax of type lists is
    "( <type>, ... <type> )"

expr_command_start: ID AS TYPEOF LPAREN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 231.
##
## ty -> TYPEOF LPAREN expr . RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BEGIN BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## TYPEOF LPAREN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ")" in typeof term.
The syntax of typeof is
    "typeof ( $0 )"

declarations_start: VAR ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 242.
##
## variable_declaration -> VAR ident COLON ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## VAR ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

A semicolon is expected at the end of a mutable variable declaration.

declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_TWO WHILE
##
## Ends in an error in state: 244.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_TWO . binop EQ separated_nonempty_list(COMMA,ident) SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_TWO
##

Binary operator declarations should be declared like this
    "__operator2 <binop> = <function list>;"

declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_TWO AMPERSAND_AMPERSAND WHILE
##
## Ends in an error in state: 245.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_TWO binop . EQ separated_nonempty_list(COMMA,ident) SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_TWO binop
##

Binary operator declarations should be declared like this
    "__operator2 $0 = <function list>;"


declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_TWO AMPERSAND_AMPERSAND EQ WHILE
##
## Ends in an error in state: 246.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_TWO binop EQ . separated_nonempty_list(COMMA,ident) SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_TWO binop EQ
##

Binary operator declarations should be declared like this
    "__operator2 $1 = <function list>;"


declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_TWO AMPERSAND_AMPERSAND EQ ID RPAREN
##
## Ends in an error in state: 247.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_TWO binop EQ separated_nonempty_list(COMMA,ident) . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_TWO binop EQ separated_nonempty_list(COMMA,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
##

Binary operator declarations should be declared like this
    "__operator2 $1 = <function list>;"

declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_ONE WHILE
##
## Ends in an error in state: 249.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_ONE . unop EQ separated_nonempty_list(COMMA,ident) SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_ONE
##

Unary operator declarations should be declared like this
    "__operator1 <unop> = <function list>;"


declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_ONE BANG WHILE
##
## Ends in an error in state: 251.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_ONE unop . EQ separated_nonempty_list(COMMA,ident) SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_ONE unop
##

Unary operator declarations should be declared like this
    "__operator1 $0 = <function list>;"

declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_ONE BANG EQ WHILE
##
## Ends in an error in state: 252.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_ONE unop EQ . separated_nonempty_list(COMMA,ident) SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_ONE unop EQ
##

Unary operator declarations should be declared like this
    "__operator1 $1 = <function list>;"

declarations_start: UNDERSCORE_UNDERSCORE_OPERATOR_ONE BANG EQ ID RPAREN
##
## Ends in an error in state: 253.
##
## internal_definition -> UNDERSCORE_UNDERSCORE_OPERATOR_ONE unop EQ separated_nonempty_list(COMMA,ident) . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_OPERATOR_ONE unop EQ separated_nonempty_list(COMMA,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
##

Missing semicolon.
Unary operator declarations should be declared like this
    "__operator1 $2 = $0;"

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN WHILE
##
## Ends in an error in state: 255.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN . FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN . TYPE ident SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN
##

Builtin types and functions are declared like this
    "__builtin type <type identifier>;"
or
    "__builtin func <function identifier>(<arguments>) => <return type>;"

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN TYPE WHILE
##
## Ends in an error in state: 256.
##
## type_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN TYPE . ident SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN TYPE
##

Missing type name.
Builtin types are declared like this
    "__builtin type <type identifier>;"


declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN TYPE ID WHILE
##
## Ends in an error in state: 257.
##
## type_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN TYPE ident . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN TYPE ident
##

Missing semicolon.
Builtin types are declared like this
    "__builtin type $0;"


declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC WHILE
##
## Ends in an error in state: 259.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC . ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC
##

Builtin functions are declared like this
    "__builtin func <function identifier>(<arguments>) => <return type>;"

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID WHILE
##
## Ends in an error in state: 260.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident . throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident
##

Builtin functions are declared like this
    "__builtin func $0(<arguments>) => <return type>;"
or this
    "__builtin func $0{parameters}(<arguments>) => <return type>;"


declarations_start: FUNC ID LBRACE WHILE
##
## Ends in an error in state: 262.
##
## parameters_opt -> LBRACE . parameter_list RBRACE [ LPAREN LBRACK EQ_GT EQ ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Parameter list expected.
Parameters look like "{M}" or "{M : integer}"

declarations_start: FUNC ID LBRACE ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 266.
##
## separated_nonempty_list(COMMA,parameter) -> parameter . [ RBRACE ]
## separated_nonempty_list(COMMA,parameter) -> parameter . COMMA separated_nonempty_list(COMMA,parameter) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## parameter
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
## In state 271, spurious reduction of production ty_opt -> COLON ty
## In state 272, spurious reduction of production parameter -> ident ty_opt
##

Parameter list expected.
Parameters look like "{M}" or "{M : integer}"

declarations_start: FUNC ID LBRACE ID COMMA WHILE
##
## Ends in an error in state: 267.
##
## separated_nonempty_list(COMMA,parameter) -> parameter COMMA . separated_nonempty_list(COMMA,parameter) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## parameter COMMA
##

Parameter list expected.
Parameter lists look like "{M, N}" or "{M : integer, N}"

declarations_start: FUNC ID LBRACE ID WHILE
##
## Ends in an error in state: 269.
##
## parameter -> ident . ty_opt [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ident
##

Parameter list expected.
Parameter lists look like "{M : integer, N}" or "{M, N}"

declarations_start: CONSTANT ID COLON WHILE
##
## Ends in an error in state: 270.
##
## ty_opt -> COLON . ty [ RPAREN RBRACK RBRACE EQ COMMA ]
##
## The known suffix of the stack is as follows:
## COLON
##

Type annotation such as ": bits(32)" expected.

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID LBRACE ID RBRACE WHILE
##
## Ends in an error in state: 273.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt . LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt
##

Function argument list of the form "(<arg1> : <type1>, <arg2> : <type2> ...)" expected.


declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID LPAREN WHILE
##
## Ends in an error in state: 274.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN . formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN
##

Function argument list of the form "(<arg1> : <type1>, <arg2> : <type2> ...)" expected.

declarations_start: FUNC ID LPAREN ID WHILE
##
## Ends in an error in state: 277.
##
## formal_with_default -> ident . COLON ty [ RPAREN COMMA ]
## formal_with_default -> ident . COLON ty EQ expr [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## ident
##

Function arguments are of the form "$0 : <type>"


declarations_start: FUNC ID LPAREN ID COLON WHILE
##
## Ends in an error in state: 278.
##
## formal_with_default -> ident COLON . ty [ RPAREN COMMA ]
## formal_with_default -> ident COLON . ty EQ expr [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## ident COLON
##

Function arguments are of the form "$1 : <type>"

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID LPAREN ID COLON INTEGER RBRACK
##
## Ends in an error in state: 279.
##
## formal_with_default -> ident COLON ty . [ RPAREN COMMA ]
## formal_with_default -> ident COLON ty . EQ expr [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Function argument lists should end in ")". For example 
    "__builtin func $3$2($1);"
or
    "__builtin func $3$2($1) => <return type>";

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 283.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN . EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN
##

Missing return type or semicolon.
For example
    "__builtin func $4$3($1);"
or
    "__builtin func $4$3($1) => <return type>";

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID LPAREN RPAREN EQ_GT WHILE
##
## Ends in an error in state: 284.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT
##

Missing return type.
For example
    "__builtin func $5$4($2) => <return type>;"

declarations_start: UNDERSCORE_UNDERSCORE_BUILTIN FUNC ID LPAREN RPAREN EQ_GT INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 285.
##
## function_declaration -> UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_BUILTIN FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon.
For example
    "__builtin func $6$5($3) => $0;"

declarations_start: FUNC ID LPAREN ID COLON INTEGER COMMA WHILE
##
## Ends in an error in state: 288.
##
## separated_nonempty_list(COMMA,formal_with_default) -> formal_with_default COMMA . separated_nonempty_list(COMMA,formal_with_default) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## formal_with_default COMMA
##

Function argument list of the form "(<arg1> : <type1>, <arg2> : <type2> ...)" expected.

declarations_start: TYPE WHILE
##
## Ends in an error in state: 290.
##
## type_declaration -> TYPE . ident SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident ty_params OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident OF EXCEPTION SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident OF EXCEPTION LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident OF ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident ty_params OF ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE . ident OF ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE
##

identifier expected.
The syntax of type declarations is
    "type <type identifier> of <type>;"
or
    "type <type identifier>{type parameters} of <type>;"

declarations_start: TYPE ID WHILE
##
## Ends in an error in state: 291.
##
## type_declaration -> TYPE ident . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . ty_params OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . OF EXCEPTION SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . OF EXCEPTION LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . OF ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . ty_params OF ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident . OF ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident
##

The syntax of type declarations is
    "type <type identifier> of <type>;"
or
    "type <type identifier>{<type parameters>} of <type>;"

declarations_start: TYPE ID OF WHILE
##
## Ends in an error in state: 293.
##
## type_declaration -> TYPE ident OF . RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident OF . EXCEPTION SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident OF . EXCEPTION LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident OF . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident OF . ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF
##

The syntax of type declarations is
    "type $1 of <type>;"
or
    "type $1{type parameters} of <type>;"

declarations_start: TYPE ID OF RECORD WHILE
##
## Ends in an error in state: 294.
##
## type_declaration -> TYPE ident OF RECORD . LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF RECORD
##

    "{" expected.
The syntax of record type declarations is
    "type $2 of record { <field_name> : <type>, ... };"

declarations_start: TYPE ID OF RECORD LBRACE WHILE
##
## Ends in an error in state: 295.
##
## type_declaration -> TYPE ident OF RECORD LBRACE . separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF RECORD LBRACE
##

    "{" expected.
The syntax of record type declarations is
    "type $3 of record { <field_name> : <type>, ... };"


declarations_start: TYPE ID OF RECORD LBRACE ID COLON INTEGER RBRACE WHILE
##
## Ends in an error in state: 297.
##
## type_declaration -> TYPE ident OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE
##

    ";" expected.
The syntax of record type declarations is
    "type $5 of record { $1 };"

declarations_start: TYPE ID OF EXCEPTION LBRACE ID WHILE
##
## Ends in an error in state: 299.
##
## field_asl1 -> ident . COLON ty [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ident
##

Missing type annotation in field.
The syntax of field lists is
    "<field1> : <type1>, ..."

declarations_start: TYPE ID OF EXCEPTION LBRACE ID COLON WHILE
##
## Ends in an error in state: 300.
##
## field_asl1 -> ident COLON . ty [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ident COLON
##

Missing type annotation in field.
The syntax of field lists is
    "<field1> : <type1>, ..."

declarations_start: TYPE ID OF EXCEPTION LBRACE ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 302.
##
## separated_nonempty_list(COMMA,field_asl1) -> field_asl1 . [ RBRACE ]
## separated_nonempty_list(COMMA,field_asl1) -> field_asl1 . COMMA separated_nonempty_list(COMMA,field_asl1) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_asl1
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
## In state 301, spurious reduction of production field_asl1 -> ident COLON ty
##

The syntax of field lists is
    "$0, <field> : <type>, ..."


declarations_start: TYPE ID OF EXCEPTION LBRACE ID COLON INTEGER COMMA WHILE
##
## Ends in an error in state: 303.
##
## separated_nonempty_list(COMMA,field_asl1) -> field_asl1 COMMA . separated_nonempty_list(COMMA,field_asl1) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_asl1 COMMA
##

The syntax of field lists is
    "$1, <field> : <type>, ..."

declarations_start: TYPE ID OF EXCEPTION WHILE
##
## Ends in an error in state: 305.
##
## type_declaration -> TYPE ident OF EXCEPTION . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident OF EXCEPTION . LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF EXCEPTION
##

Missing semicolon or field list.
The syntax of exception declarations is
    "type $2 of exception;"
or
    "type $2 of exception { <field1> : <type1>, ... };"


declarations_start: TYPE ID OF EXCEPTION LBRACE WHILE
##
## Ends in an error in state: 307.
##
## type_declaration -> TYPE ident OF EXCEPTION LBRACE . separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF EXCEPTION LBRACE
##

Missing field list.
The syntax of exception declarations is
    "type $3 of exception { <field1> : <type1>, ... };"


declarations_start: TYPE ID OF EXCEPTION LBRACE ID COLON INTEGER RBRACE WHILE
##
## Ends in an error in state: 309.
##
## type_declaration -> TYPE ident OF EXCEPTION LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF EXCEPTION LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE
##

Missing semicolon.
The syntax of exception declarations is
    "type $5 of exception { $1 };"

declarations_start: TYPE ID OF ENUMERATION WHILE
##
## Ends in an error in state: 311.
##
## type_declaration -> TYPE ident OF ENUMERATION . LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF ENUMERATION
##

Missing list of enumeration constants.
The syntax of enumeration declarations is
    "type $2 of enumeration { RED, GREEN, BLUE };"

declarations_start: TYPE ID OF ENUMERATION LBRACE WHILE
##
## Ends in an error in state: 312.
##
## type_declaration -> TYPE ident OF ENUMERATION LBRACE . loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF ENUMERATION LBRACE
##

Missing list of enumeration constants.
The syntax of enumeration declarations is
    "type $2 of enumeration { RED, GREEN, BLUE };"

declarations_start: TYPE ID OF ENUMERATION LBRACE ID SEMICOLON
##
## Ends in an error in state: 314.
##
## type_declaration -> TYPE ident OF ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident)) . RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
## In state 313, spurious reduction of production loption(separated_nonempty_list(COMMA,ident)) -> separated_nonempty_list(COMMA,ident)
##

Missing "}" or malformed list of enumeration constants.
The syntax of enumeration declarations is
    "type $4 of enumeration { $0 };"


declarations_start: TYPE ID OF ENUMERATION LBRACE RBRACE WHILE
##
## Ends in an error in state: 315.
##
## type_declaration -> TYPE ident OF ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF ENUMERATION LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE
##

Missing ";".
The syntax of enumeration declarations is
    "type $5 of enumeration { $1 };"

declarations_start: TYPE ID OF INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 317.
##
## type_declaration -> TYPE ident OF ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident OF ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing ";".
The syntax of type declarations is
    "type $2 of $0;"

declarations_start: RECORD ID LPAREN WHILE
##
## Ends in an error in state: 319.
##
## ty_params -> LPAREN . separated_nonempty_list(COMMA,ident) RPAREN [ OF LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Malformed parameter list.
The syntax of record declarations is
    "record R of { <fields> };"
or
    "record R(<parameter list>) of { <fields> };"

declarations_start: RECORD ID LPAREN ID SEMICOLON
##
## Ends in an error in state: 320.
##
## ty_params -> LPAREN separated_nonempty_list(COMMA,ident) . RPAREN [ OF LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAREN separated_nonempty_list(COMMA,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
##

Malformed parameter list.
The syntax of record declarations is
    "record R of { <fields> };"
or
    "record R(<parameter list>) of { <fields> };"

declarations_start: TYPE ID LPAREN ID RPAREN WHILE
##
## Ends in an error in state: 322.
##
## type_declaration -> TYPE ident ty_params . OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident ty_params . OF ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident ty_params
##


Missing "of" keyword.
    "type $1$0 of <type>;"
or
    "type $1$0 of record { <fields> };"

declarations_start: TYPE ID LPAREN ID RPAREN OF WHILE
##
## Ends in an error in state: 323.
##
## type_declaration -> TYPE ident ty_params OF . RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> TYPE ident ty_params OF . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident ty_params OF
##

Missing type in type declaration.
    "type $2$1 of <type>;"
or
    "type $2$1 of record { <fields> };"

declarations_start: TYPE ID LPAREN ID RPAREN OF RECORD WHILE
##
## Ends in an error in state: 324.
##
## type_declaration -> TYPE ident ty_params OF RECORD . LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident ty_params OF RECORD
##

The syntax of record declarations is
    "type $3$2 of record { <fields> };"

declarations_start: TYPE ID LPAREN ID RPAREN OF RECORD LBRACE WHILE
##
## Ends in an error in state: 325.
##
## type_declaration -> TYPE ident ty_params OF RECORD LBRACE . separated_nonempty_list(COMMA,field_asl1) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident ty_params OF RECORD LBRACE
##

Malformed record field list.
The syntax of record declarations is
    "type $4$3 of record { <field1> : <type1>, ... };"

declarations_start: TYPE ID LPAREN ID RPAREN OF RECORD LBRACE ID COLON INTEGER RBRACE WHILE
##
## Ends in an error in state: 327.
##
## type_declaration -> TYPE ident ty_params OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident ty_params OF RECORD LBRACE separated_nonempty_list(COMMA,field_asl1) RBRACE
##

Missing semicolon.
The syntax of record declarations is
    "type $6$5 of record { $1 };"


declarations_start: TYPE ID LPAREN ID RPAREN OF INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 329.
##
## type_declaration -> TYPE ident ty_params OF ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## TYPE ident ty_params OF ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon.
The syntax of type declarations is
    "type $3$2 of $0;"


declarations_start: SETTER WHILE
##
## Ends in an error in state: 331.
##
## setter_declaration -> SETTER . ident throws parameters_opt EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER . ident throws parameters_opt EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER . ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER . ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER
##

Missing name of setter function.
The syntax of setter declarations is
    "setter <setter identifier> = <variable identifier> : <type> ..."
or
    "setter <setter identifier>{ <parameters> } = <variable identifier> : <type> ..."
or
    "setter <setter identifier>[ <arguments> ] = <variable identifier> : <type> ..."
or
    "setter <setter identifier>{ <parameters> }[ <arguments> ] = <variable identifier> : <type> ..."


declarations_start: SETTER ID WHILE
##
## Ends in an error in state: 332.
##
## setter_declaration -> SETTER ident . throws parameters_opt EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident . throws parameters_opt EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident . throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident . throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident
##


Malformed setter declaration.
The syntax of setter declarations is
    "setter $0 = <variable identifier> : <type> ..."
or
    "setter $0{ <parameters> } = <variable identifier> : <type> ..."
or
    "setter $0[ <arguments> ] = <variable identifier> : <type> ..."
or
    "setter $0{ <parameters> }[ <arguments> ] = <variable identifier> : <type> ..."

declarations_start: SETTER ID LBRACE ID RBRACE WHILE
##
## Ends in an error in state: 334.
##
## setter_declaration -> SETTER ident throws parameters_opt . EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt . EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt . LBRACK formal_list RBRACK EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt . LBRACK formal_list RBRACK EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt
##

Malformed setter declaration.
The syntax of setter declarations is
    "setter $1$0 = <variable identifier> : <type> ..."
or
    "setter $1$0[ <arguments> ] = <variable identifier> : <type> ..."


declarations_start: SETTER ID LBRACK WHILE
##
## Ends in an error in state: 335.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK . formal_list RBRACK EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt LBRACK . formal_list RBRACK EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK
##

The syntax of setter declarations is
    "setter $2$1[ <arg1> : <type1>, ... ] = <variable identifier> : <type> ..."

declarations_start: SETTER ID LBRACK ID COLON INTEGER RPAREN
##
## Ends in an error in state: 524.
##
## separated_nonempty_list(COMMA,formal) -> formal . [ RBRACK ]
## separated_nonempty_list(COMMA,formal) -> formal . COMMA separated_nonempty_list(COMMA,formal) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## formal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
## In state 340, spurious reduction of production formal -> ident COLON ty
##

Missing "]" or ",".
The syntax of setter declarations is
    "setter $3$2[$0] = <variable identifier> : <type> ..."

declarations_start: SETTER ID LBRACK RBRACK WHILE
##
## Ends in an error in state: 342.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK . EQ ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK . EQ ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK
##

Missing "=".
The syntax of setter declarations is
    "setter $4$3[$1] = <variable identifier> : <type> ..."


declarations_start: SETTER ID LBRACK RBRACK EQ WHILE
##
## Ends in an error in state: 343.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ . ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ . ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ
##

Missing value variable.
The syntax of setter declarations is
    "setter $5$4[$2] = <variable identifier> : <type> ..."


declarations_start: SETTER ID LBRACK RBRACK EQ ID WHILE
##
## Ends in an error in state: 344.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident . COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident . COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident
##

Missing type annotation.
The syntax of setter declarations is
    "setter $6$5[$3] = $0 : <type> ..."

declarations_start: SETTER ID LBRACK RBRACK EQ ID COLON WHILE
##
## Ends in an error in state: 345.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON . ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON
##

Missing type.
The syntax of setter declarations is
    "setter $6$5[$3] = $0 : <type>;"
or
    "setter $6$5[$3] = $0 : <type>
     begin
         ...
     end"


declarations_start: SETTER ID LBRACK RBRACK EQ ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 346.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty . BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon or function body.
The syntax of setter declarations is
    "setter $8$7[$5] = $2 : $0;"
or
    "setter $8$7[$5] = $2 : $0
     begin
         ...
     end"


declarations_start: SETTER ID LBRACK RBRACK EQ ID COLON INTEGER BEGIN WHERE
##
## Ends in an error in state: 348.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty BEGIN . block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty BEGIN
##

Malformed setter declaration.
The syntax of setter declarations is
    "setter $9$8[$6] = $3 : $1;"
or
    "setter $9$8[$6] = $3 : $1
     begin
         <statements>
     end"

stmt_command_start: WHILE WHILE
##
## Ends in an error in state: 349.
##
## repetitive_stmt -> WHILE . expr DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE
##

Expression expected in while statement.
The syntax of while statements is
    "while <expresssion> do <statements> end"

stmt_command_start: WHILE ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 350.
##
## repetitive_stmt -> WHILE expr . DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing "do" in while statement.
The syntax of while statements is
    "while $0 do <statements> end"


stmt_command_start: WHILE ID DO WHERE
##
## Ends in an error in state: 351.
##
## repetitive_stmt -> WHILE expr DO . block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO
##

Malformed while statement.
The syntax of while statements is
    "while $1 do <statements> end"

stmt_command_start: VAR WHILE
##
## Ends in an error in state: 352.
##
## assignment_stmt -> VAR . ident COMMA loption(separated_nonempty_list(COMMA,ident)) COLON ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## assignment_stmt -> VAR . ident COLON ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## assignment_stmt -> VAR . decl_item EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR
##

Malformed mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT MINUS WHILE
##
## Ends in an error in state: 353.
##
## decl_item -> MINUS . ty_opt [ RPAREN EQ COMMA ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Missing ":" in declaration item.
The syntax of wildcard declaration items is
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LPAREN WHILE
##
## Ends in an error in state: 355.
##
## decl_item -> LPAREN . separated_nonempty_list(COMMA,decl_item) RPAREN [ RPAREN EQ COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Malformed declaration item.
The syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LBRACK WHILE
##
## Ends in an error in state: 356.
##
## decl_item -> LBRACK . separated_nonempty_list(COMMA,decl_bit) RBRACK [ RPAREN EQ COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACK
##


Malformed declaration item.
The syntax of declaration items is
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"
and the syntax of declaration bitvector items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LBRACK MINUS WHILE
##
## Ends in an error in state: 357.
##
## decl_bit -> MINUS . ty_opt [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Missing ":" in declaration bitvector item.
The syntax of wildcard declaration items is
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LBRACK ID WHILE
##
## Ends in an error in state: 361.
##
## decl_bit -> ident . ty_opt [ RBRACK COMMA ]
##
## The known suffix of the stack is as follows:
## ident
##

Missing ":" in declaration bitvector item.
The syntax of declaration bitvector items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LBRACK ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 363.
##
## separated_nonempty_list(COMMA,decl_bit) -> decl_bit . [ RBRACK ]
## separated_nonempty_list(COMMA,decl_bit) -> decl_bit . COMMA separated_nonempty_list(COMMA,decl_bit) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## decl_bit
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
## In state 271, spurious reduction of production ty_opt -> COLON ty
## In state 362, spurious reduction of production decl_bit -> ident ty_opt
##

Malformed declaration bitvector list.
The syntax of declaration bitvector lists is
    "[ <declaration bitvector item list> ]"
and the syntax of declaration bitvector items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "-"
or
    "- : <type>"


stmt_command_start: CONSTANT LBRACK ID COMMA WHILE
##
## Ends in an error in state: 364.
##
## separated_nonempty_list(COMMA,decl_bit) -> decl_bit COMMA . separated_nonempty_list(COMMA,decl_bit) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## decl_bit COMMA
##

Malformed declaration bitvector list.
The syntax of declaration bitvector lists is
    "[ <declaration bitvector item list> ]"
and the syntax of declaration bitvector items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "-"
or
    "- : <type>"


stmt_command_start: CONSTANT ID WHILE
##
## Ends in an error in state: 368.
##
## decl_item -> ident . ty_opt [ RPAREN EQ COMMA ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed declaration item.
The syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LPAREN ID EQ
##
## Ends in an error in state: 370.
##
## separated_nonempty_list(COMMA,decl_item) -> decl_item . [ RPAREN ]
## separated_nonempty_list(COMMA,decl_item) -> decl_item . COMMA separated_nonempty_list(COMMA,decl_item) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## decl_item
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 368, spurious reduction of production ty_opt ->
## In state 369, spurious reduction of production decl_item -> ident ty_opt
##


Malformed declaration item.
The syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT LPAREN ID COMMA WHILE
##
## Ends in an error in state: 371.
##
## separated_nonempty_list(COMMA,decl_item) -> decl_item COMMA . separated_nonempty_list(COMMA,decl_item) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## decl_item COMMA
##

Malformed declaration item.
The syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID WHILE
##
## Ends in an error in state: 373.
##
## assignment_stmt -> VAR ident . COMMA loption(separated_nonempty_list(COMMA,ident)) COLON ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## assignment_stmt -> VAR ident . COLON ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## decl_item -> ident . ty_opt [ EQ ]
##
## The known suffix of the stack is as follows:
## VAR ident
##

Malformed mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID COMMA WHILE
##
## Ends in an error in state: 374.
##
## assignment_stmt -> VAR ident COMMA . loption(separated_nonempty_list(COMMA,ident)) COLON ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR ident COMMA
##

Malformed mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID COMMA ID SEMICOLON
##
## Ends in an error in state: 375.
##
## assignment_stmt -> VAR ident COMMA loption(separated_nonempty_list(COMMA,ident)) . COLON ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR ident COMMA loption(separated_nonempty_list(COMMA,ident))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
## In state 313, spurious reduction of production loption(separated_nonempty_list(COMMA,ident)) -> separated_nonempty_list(COMMA,ident)
##

Malformed mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID COMMA COLON WHILE
##
## Ends in an error in state: 376.
##
## assignment_stmt -> VAR ident COMMA loption(separated_nonempty_list(COMMA,ident)) COLON . ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR ident COMMA loption(separated_nonempty_list(COMMA,ident)) COLON
##

Malformed mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID COMMA COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 377.
##
## assignment_stmt -> VAR ident COMMA loption(separated_nonempty_list(COMMA,ident)) COLON ty . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR ident COMMA loption(separated_nonempty_list(COMMA,ident)) COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##


Missing ";" in mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID COLON WHILE
##
## Ends in an error in state: 379.
##
## assignment_stmt -> VAR ident COLON . ty SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## ty_opt -> COLON . ty [ EQ ]
##
## The known suffix of the stack is as follows:
## VAR ident COLON
##

Missing type in mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 380.
##
## assignment_stmt -> VAR ident COLON ty . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## ty_opt -> COLON ty . [ EQ ]
##
## The known suffix of the stack is as follows:
## VAR ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing ";" in mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var <identifier> : <type>;" 
or
    "var <identifier>, ... <identifier> : <type>;" 
or
    "var <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: VAR MINUS RPAREN
##
## Ends in an error in state: 382.
##
## assignment_stmt -> VAR decl_item . EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR decl_item
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 353, spurious reduction of production ty_opt ->
## In state 354, spurious reduction of production decl_item -> MINUS ty_opt
##

Missing initializer in mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var - = <expression>;"
or
    "var - : <type> = <expression>;"

stmt_command_start: VAR ID EQ WHILE
##
## Ends in an error in state: 383.
##
## assignment_stmt -> VAR decl_item EQ . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR decl_item EQ
##

Missing initializer in mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var $1 = <expression>;"

stmt_command_start: VAR ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 384.
##
## assignment_stmt -> VAR decl_item EQ expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## VAR decl_item EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";" in mutable variable declaration.
The syntax of mutable variable declaration statements is
    "var $2 = $0;"

stmt_command_start: TRY WHERE
##
## Ends in an error in state: 386.
##
## catch_stmt -> TRY . block CATCH pos list(catcher) opt_otherwise END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY
##

Malformed try-catch statement.
The syntax of try-catch statements is
    "try <statements> catch <catcher list> end"

stmt_command_start: THROW WHILE
##
## Ends in an error in state: 387.
##
## simple_stmt -> THROW . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## THROW
##

Malformed throw statement.
The syntax of throw statements is
    "throw <expression>;"

stmt_command_start: THROW ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 388.
##
## simple_stmt -> THROW expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## THROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##


Missing ";" in throw statement.
The syntax of throw statements is
    "throw <expression>;"

stmt_command_start: RETURN WHILE
##
## Ends in an error in state: 390.
##
## simple_stmt -> RETURN . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## simple_stmt -> RETURN . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## RETURN
##

Malformed return statement.
The syntax of return statements is
    "return <expression>;"

stmt_command_start: RETURN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 392.
##
## simple_stmt -> RETURN expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## RETURN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";" in return statement.
The syntax of return statements is
    "return <expression>;"

stmt_command_start: REPEAT WHERE
##
## Ends in an error in state: 394.
##
## repetitive_stmt -> REPEAT . block UNTIL expr SEMICOLON pos [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## REPEAT
##

Malformed repeat statement.
The syntax of repeat statements is
    "repeat <statements> until <expression>;"

stmt_command_start: LPAREN WHILE
##
## Ends in an error in state: 396.
##
## lexpr -> LPAREN . separated_nonempty2_list(COMMA,lexpr) RPAREN [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
## lexpr -> LPAREN . lexpr RPAREN [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: LBRACK WHILE
##
## Ends in an error in state: 397.
##
## lexpr -> LBRACK . separated_nonempty2_list(COMMA,lexpr) RBRACK [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: LBRACK ID COMMA ID RPAREN
##
## Ends in an error in state: 398.
##
## lexpr -> LBRACK separated_nonempty2_list(COMMA,lexpr) . RBRACK [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACK separated_nonempty2_list(COMMA,lexpr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 411, spurious reduction of production separated_nonempty2_list(COMMA,lexpr) -> lexpr COMMA lexpr
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: LBRACK ID WHILE
##
## Ends in an error in state: 400.
##
## lexpr -> lexpr . DOT ident [ LBRACK DOT COMMA ]
## lexpr -> lexpr . DOT LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ LBRACK DOT COMMA ]
## lexpr -> lexpr . LBRACK loption(separated_nonempty_list(COMMA,slice)) RBRACK [ LBRACK DOT COMMA ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr . COMMA lexpr [ RBRACK ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr . COMMA separated_nonempty2_list(COMMA,lexpr) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## lexpr
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"


stmt_command_start: ID LBRACK WHILE
##
## Ends in an error in state: 401.
##
## lexpr -> lexpr LBRACK . loption(separated_nonempty_list(COMMA,slice)) RBRACK [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## lexpr LBRACK
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: ID DOT WHILE
##
## Ends in an error in state: 404.
##
## lexpr -> lexpr DOT . ident [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
## lexpr -> lexpr DOT . LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## lexpr DOT
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: ID DOT LBRACK WHILE
##
## Ends in an error in state: 405.
##
## lexpr -> lexpr DOT LBRACK . separated_nonempty_list(COMMA,ident) RBRACK [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## lexpr DOT LBRACK
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: ID DOT LBRACK ID SEMICOLON
##
## Ends in an error in state: 406.
##
## lexpr -> lexpr DOT LBRACK separated_nonempty_list(COMMA,ident) . RBRACK [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## lexpr DOT LBRACK separated_nonempty_list(COMMA,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"


stmt_command_start: LBRACK ID COMMA WHILE
##
## Ends in an error in state: 409.
##
## separated_nonempty2_list(COMMA,lexpr) -> lexpr COMMA . lexpr [ RPAREN RBRACK ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr COMMA . separated_nonempty2_list(COMMA,lexpr) [ RPAREN RBRACK ]
##
## The known suffix of the stack is as follows:
## lexpr COMMA
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"

stmt_command_start: LBRACK ID COMMA ID WHILE
##
## Ends in an error in state: 411.
##
## lexpr -> lexpr . DOT ident [ RPAREN RBRACK LBRACK DOT COMMA ]
## lexpr -> lexpr . DOT LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ RPAREN RBRACK LBRACK DOT COMMA ]
## lexpr -> lexpr . LBRACK loption(separated_nonempty_list(COMMA,slice)) RBRACK [ RPAREN RBRACK LBRACK DOT COMMA ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr . COMMA lexpr [ RPAREN RBRACK ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr COMMA lexpr . [ RPAREN RBRACK ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr . COMMA separated_nonempty2_list(COMMA,lexpr) [ RPAREN RBRACK ]
##
## The known suffix of the stack is as follows:
## lexpr COMMA lexpr
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"


stmt_command_start: LPAREN ID COMMA ID RBRACK
##
## Ends in an error in state: 413.
##
## lexpr -> LPAREN separated_nonempty2_list(COMMA,lexpr) . RPAREN [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN separated_nonempty2_list(COMMA,lexpr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 411, spurious reduction of production separated_nonempty2_list(COMMA,lexpr) -> lexpr COMMA lexpr
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"


stmt_command_start: LPAREN ID WHILE
##
## Ends in an error in state: 415.
##
## lexpr -> lexpr . DOT ident [ RPAREN LBRACK DOT COMMA ]
## lexpr -> lexpr . DOT LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ RPAREN LBRACK DOT COMMA ]
## lexpr -> lexpr . LBRACK loption(separated_nonempty_list(COMMA,slice)) RBRACK [ RPAREN LBRACK DOT COMMA ]
## lexpr -> LPAREN lexpr . RPAREN [ RPAREN RBRACK LBRACK EQ DOT COMMA ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr . COMMA lexpr [ RPAREN ]
## separated_nonempty2_list(COMMA,lexpr) -> lexpr . COMMA separated_nonempty2_list(COMMA,lexpr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## LPAREN lexpr
##

Malformed L-expression.
The syntax of L-expressions is
    "-"
or
    "<variable identifier>"
or
    "<L-expression> . <field identifier>"
or
    "<L-expression> . [ <field identifier list> ]"
or
    "<L-expression> [ <slice list> ]"
or
    "[ <L-expression list> ]"
or
    "( <L-expression list> )"


stmt_command_start: LET WHILE
##
## Ends in an error in state: 417.
##
## assignment_stmt -> LET . decl_item EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## LET
##

Malformed immutable variable assignment.
The syntax of immutable variable assignments is
    "let <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: LET ID RPAREN
##
## Ends in an error in state: 418.
##
## assignment_stmt -> LET decl_item . EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## LET decl_item
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 368, spurious reduction of production ty_opt ->
## In state 369, spurious reduction of production decl_item -> ident ty_opt
##

Missing initializer in immutable variable assignment.
The syntax of immutable variable assignments is
    "let <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: LET ID EQ WHILE
##
## Ends in an error in state: 419.
##
## assignment_stmt -> LET decl_item EQ . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## LET decl_item EQ
##

Missing initializer in immutable variable assignment.
The syntax of immutable variable assignments is
    "let <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"


stmt_command_start: LET ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 420.
##
## assignment_stmt -> LET decl_item EQ expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## LET decl_item EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";" in immutable variable assignment.
The syntax of immutable variable assignments is
    "let $2 = $0;"

stmt_command_start: IF WHILE
##
## Ends in an error in state: 422.
##
## conditional_stmt -> IF . expr THEN block list(s_elsif) optional_else END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## IF
##

Malformed if statement.
The syntax of if statements is
    "if <expression> then <statements> else <statements> end"
or
    "if <expression> then <statements> elsif ... else <statements> end"

stmt_command_start: IF ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 423.
##
## conditional_stmt -> IF expr . THEN block list(s_elsif) optional_else END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## IF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed if statement.
The syntax of if statements is
    "if <expression> then <statements> else <statements> end"
or
    "if <expression> then <statements> elsif ... else <statements> end"

stmt_command_start: IF ID THEN WHERE
##
## Ends in an error in state: 424.
##
## conditional_stmt -> IF expr THEN . block list(s_elsif) optional_else END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## IF expr THEN
##

Malformed if statement.
The syntax of if statements is
    "if $1 then <statements> else <statements> end"
or
    "if $1 then <statements> elsif ... else <statements> end"

stmt_command_start: FOR WHILE
##
## Ends in an error in state: 425.
##
## repetitive_stmt -> FOR . ident ty_opt EQ expr direction expr DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR
##

Malformed for statement.
The syntax of for statements is
    "for <variable identifier> = <expression> to/downto <expression> do <statements> end"

stmt_command_start: FOR ID WHILE
##
## Ends in an error in state: 426.
##
## repetitive_stmt -> FOR ident . ty_opt EQ expr direction expr DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident
##

Malformed for statement.
The syntax of for statements is
    "for <variable identifier> = <expression> to/downto <expression> do <statements> end"


stmt_command_start: FOR ID EQ WHILE
##
## Ends in an error in state: 428.
##
## repetitive_stmt -> FOR ident ty_opt EQ . expr direction expr DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident ty_opt EQ
##

Malformed for statement.
The syntax of for statements is
    "for <variable identifier> = <expression> to/downto <expression> do <statements> end"

stmt_command_start: FOR ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 429.
##
## repetitive_stmt -> FOR ident ty_opt EQ expr . direction expr DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident ty_opt EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed for statement.
The syntax of for statements is
    "for <variable identifier> = <expression> to/downto <expression> do <statements> end"


stmt_command_start: FOR ID EQ ID DOWNTO WHILE
##
## Ends in an error in state: 432.
##
## repetitive_stmt -> FOR ident ty_opt EQ expr direction . expr DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident ty_opt EQ expr direction
##

Malformed for statement.
The syntax of for statements is
    "for $3 = $1 $0 <expression> do <statements> end"

stmt_command_start: FOR ID EQ ID DOWNTO ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 433.
##
## repetitive_stmt -> FOR ident ty_opt EQ expr direction expr . DO block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident ty_opt EQ expr direction expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed for statement.
The syntax of for statements is
    "for $4 = $2 $1 $0 do <statements> end"

stmt_command_start: FOR ID EQ ID DOWNTO ID DO WHERE
##
## Ends in an error in state: 434.
##
## repetitive_stmt -> FOR ident ty_opt EQ expr direction expr DO . block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident ty_opt EQ expr direction expr DO
##

Malformed for statement body.
The syntax of for statements is
    "for $5 = $3 $2 $1 do <statements> end"


stmt_command_start: CONSTANT WHILE
##
## Ends in an error in state: 435.
##
## assignment_stmt -> CONSTANT . decl_item EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CONSTANT
##

Malformed constant assignment.
The syntax of constant assignments is
    "constant <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT ID RPAREN
##
## Ends in an error in state: 436.
##
## assignment_stmt -> CONSTANT decl_item . EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CONSTANT decl_item
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 368, spurious reduction of production ty_opt ->
## In state 369, spurious reduction of production decl_item -> ident ty_opt
##


Malformed constant assignment.
The syntax of constant assignments is
    "constant <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"

stmt_command_start: CONSTANT ID EQ WHILE
##
## Ends in an error in state: 437.
##
## assignment_stmt -> CONSTANT decl_item EQ . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CONSTANT decl_item EQ
##

Malformed constant assignment.
The syntax of constant assignments is
    "constant <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"


stmt_command_start: CONSTANT ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 438.
##
## assignment_stmt -> CONSTANT decl_item EQ expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CONSTANT decl_item EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed constant assignment.
The syntax of constant assignments is
    "constant <declaration item> = <expression>;"
and the syntax of declaration items is
    "<identifier>"
or
    "<identifier> : <type>"
or
    "( <declaration item list> )"
or
    "[ <declaration bitvector item list> ]"
or
    "-"
or
    "- : <type>"


stmt_command_start: CASE WHILE
##
## Ends in an error in state: 440.
##
## conditional_stmt -> CASE . expr OF nonempty_list(alt) opt_otherwise END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CASE
##

Malformed case statement.
The syntax of case statements is
    "case <expression> of
         when <guarded pattern> => <statements>
         ...
         otherwise => <statements>    // optional
     end"

stmt_command_start: CASE ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 441.
##
## conditional_stmt -> CASE expr . OF nonempty_list(alt) opt_otherwise END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CASE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing "of" in case statement.
The syntax of case statements is
    "case $0 of
         when <guarded pattern> => <statements>
         ...
         otherwise => <statements>    // optional
     end"


stmt_command_start: CASE ID OF WHILE
##
## Ends in an error in state: 442.
##
## conditional_stmt -> CASE expr OF . nonempty_list(alt) opt_otherwise END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CASE expr OF
##

Malformed case statement.
The syntax of case statements is
    "case $1 of
         when <guarded pattern> => <statements>
         ...
         otherwise => <statements>    // optional
     end"

stmt_command_start: CASE ID OF WHEN WHILE
##
## Ends in an error in state: 443.
##
## alt -> WHEN . separated_nonempty_list(COMMA,pattern) opt_altcond EQ_GT block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN
##


Malformed case alternative.
The syntax of case alternatives is
    "when <pattern> => <statements>"
or
    "when <pattern> where <guard expression> => <statements>"

stmt_command_start: CASE ID OF WHEN ID WHERE WHILE
##
## Ends in an error in state: 445.
##
## opt_altcond -> WHERE . expr [ EQ_GT ]
##
## The known suffix of the stack is as follows:
## WHERE
##

Malformed case alternative.
The syntax of case alternatives is
    "when <pattern> => <statements>"
or
    "when <pattern> where <guard expression> => <statements>"

stmt_command_start: CASE ID OF WHEN ID WHERE ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 447.
##
## alt -> WHEN separated_nonempty_list(COMMA,pattern) opt_altcond . EQ_GT block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN separated_nonempty_list(COMMA,pattern) opt_altcond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 446, spurious reduction of production opt_altcond -> WHERE expr
##

Missing "=>" in case alternative.
The syntax of case alternatives is
    "when $1 $0 => <statements>"

stmt_command_start: CASE ID OF WHEN ID EQ_GT WHERE
##
## Ends in an error in state: 448.
##
## alt -> WHEN separated_nonempty_list(COMMA,pattern) opt_altcond EQ_GT . block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN separated_nonempty_list(COMMA,pattern) opt_altcond EQ_GT
##

Malformed case alternative.
The syntax of case alternatives is
    "when $2 $1 => <statements>"

stmt_command_start: BEGIN WHERE
##
## Ends in an error in state: 449.
##
## compound_stmt -> BEGIN . block END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## BEGIN
##

Malformed begin-end statement.
The syntax of begin-end statements is
    "begin <statements> end"

stmt_command_start: ASSERT WHILE
##
## Ends in an error in state: 450.
##
## simple_stmt -> ASSERT . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## ASSERT
##

Malformed assert statement.
The syntax of assert statements is
    "assert <expression>;"

stmt_command_start: ASSERT ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 451.
##
## simple_stmt -> ASSERT expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## ASSERT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed assert statement.
The syntax of assert statements is
    "assert <expression>;"

stmts_command_start: BEGIN END WHERE
##
## Ends in an error in state: 453.
##
## list(stmt) -> stmt . list(stmt) [ WHEN UNTIL OTHERWISE EOF END ELSIF ELSE CATCH ]
##
## The known suffix of the stack is as follows:
## stmt
##

Malformed statement list.
The syntax of statement lists is
    "<statement1> <statement2> ... <statement>"

stmt_command_start: MINUS WHILE
##
## Ends in an error in state: 457.
##
## assignment_stmt -> lexpr . EQ expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
## lexpr -> lexpr . DOT ident [ LBRACK EQ DOT ]
## lexpr -> lexpr . DOT LBRACK separated_nonempty_list(COMMA,ident) RBRACK [ LBRACK EQ DOT ]
## lexpr -> lexpr . LBRACK loption(separated_nonempty_list(COMMA,slice)) RBRACK [ LBRACK EQ DOT ]
##
## The known suffix of the stack is as follows:
## lexpr
##

Malformed assignment statement.
The syntax of assignment statements is
    "<L expression> = <expression>;"

stmt_command_start: ID EQ WHILE
##
## Ends in an error in state: 458.
##
## assignment_stmt -> lexpr EQ . expr SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## lexpr EQ
##

Malformed assignment statement.
The syntax of assignment statements is
    "$1 = <expression>;"

stmt_command_start: ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 459.
##
## assignment_stmt -> lexpr EQ expr . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## lexpr EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";" in assignment statement.
The syntax of assignment statements is
    "$2 = <expression>;"


stmt_command_start: ID WHILE
##
## Ends in an error in state: 461.
##
## lexpr -> ident . [ LBRACK EQ DOT ]
## simple_stmt -> ident . throws LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN throws SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed statement that starts with an identifier.
The syntax of statements that start with an identifier is
    "<L expression> = <expression>;"                 - assignment
or
    "<function identifer>( <expression list> );"     - procedure call

stmt_command_start: ID LPAREN WHILE
##
## Ends in an error in state: 463.
##
## simple_stmt -> ident throws LPAREN . loption(separated_nonempty_list(COMMA,arg)) RPAREN throws SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## ident throws LPAREN
##

Malformed procedure call.
The syntax of procedure calls is
    "<function identifer>( <expression list> );"

stmt_command_start: ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 465.
##
## simple_stmt -> ident throws LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN . throws SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## ident throws LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN
##

Malformed procedure call.
The syntax of procedure calls is
    "<function identifer>( <expression list> );"

stmt_command_start: ID LPAREN RPAREN QUERY WHILE
##
## Ends in an error in state: 466.
##
## simple_stmt -> ident throws LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN throws . SEMICOLON [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## ident throws LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN throws
##

Malformed procedure call.
The syntax of procedure calls is
    "<function identifer>( <expression list> );"

stmt_command_start: BEGIN BEGIN END CATCH
##
## Ends in an error in state: 473.
##
## compound_stmt -> BEGIN block . END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Missing "end" in begin-end statement.
The syntax of begin-end statements is
    "begin <statements> end"


stmt_command_start: CASE ID OF WHEN ID WHILE
##
## Ends in an error in state: 476.
##
## separated_nonempty_list(COMMA,pattern) -> pattern . [ WHERE EQ_GT ]
## separated_nonempty_list(COMMA,pattern) -> pattern . COMMA separated_nonempty_list(COMMA,pattern) [ WHERE EQ_GT ]
##
## The known suffix of the stack is as follows:
## pattern
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"

stmt_command_start: CASE ID OF WHEN ID COMMA WHILE
##
## Ends in an error in state: 477.
##
## separated_nonempty_list(COMMA,pattern) -> pattern COMMA . separated_nonempty_list(COMMA,pattern) [ WHERE EQ_GT ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Malformed pattern list.
The syntax of pattern lists is
    "<pattern>, ... <pattern>"

stmt_command_start: TRY CATCH OTHERWISE WHILE
##
## Ends in an error in state: 480.
##
## opt_otherwise -> OTHERWISE . EQ_GT block [ END ]
##
## The known suffix of the stack is as follows:
## OTHERWISE
##

Missing "=>" in otherwise alternative.
The syntax of otherwise alternatives is
    "otherwise => <statements>"

stmt_command_start: TRY CATCH OTHERWISE EQ_GT WHERE
##
## Ends in an error in state: 481.
##
## opt_otherwise -> OTHERWISE EQ_GT . block [ END ]
##
## The known suffix of the stack is as follows:
## OTHERWISE EQ_GT
##

Malformed otherwise alternative.
The syntax of otherwise alternatives is
    "otherwise => <statements>"

stmt_command_start: CASE ID OF WHEN ID EQ_GT OTHERWISE EQ_GT BEGIN END CATCH
##
## Ends in an error in state: 483.
##
## conditional_stmt -> CASE expr OF nonempty_list(alt) opt_otherwise . END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## CASE expr OF nonempty_list(alt) opt_otherwise
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
## In state 482, spurious reduction of production opt_otherwise -> OTHERWISE EQ_GT block
##

Malformed case statement.
The syntax of case statements is
    "case $1 of
         when <guarded pattern> => <statements>
         ...
         otherwise => <statements>    // optional
     end"

stmt_command_start: CASE ID OF WHEN ID EQ_GT BEGIN END CATCH
##
## Ends in an error in state: 485.
##
## nonempty_list(alt) -> alt . [ OTHERWISE END ]
## nonempty_list(alt) -> alt . nonempty_list(alt) [ OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## alt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
## In state 475, spurious reduction of production alt -> WHEN separated_nonempty_list(COMMA,pattern) opt_altcond EQ_GT block
##

Malformed case statement.
The syntax of case statements is
    "case $1 of
         when <guarded pattern> => <statements>
         ...
         otherwise => <statements>    // optional
     end"

stmt_command_start: FOR ID EQ ID DOWNTO ID DO BEGIN END CATCH
##
## Ends in an error in state: 487.
##
## repetitive_stmt -> FOR ident ty_opt EQ expr direction expr DO block . END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR ident ty_opt EQ expr direction expr DO block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed for statement.
The syntax of for statements is
    "for <variable identifier> = <expression> to/downto <expression> do <statements> end"

stmt_command_start: IF ID THEN BEGIN END CATCH
##
## Ends in an error in state: 489.
##
## conditional_stmt -> IF expr THEN block . list(s_elsif) optional_else END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## IF expr THEN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed if statement.
The syntax of if statements is
    "if <expression> then <statements> else <statements> end"
or
    "if <expression> then <statements> elsif ... else <statements> end"

stmt_command_start: IF ID THEN ELSIF WHILE
##
## Ends in an error in state: 490.
##
## s_elsif -> ELSIF . expr THEN block [ END ELSIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSIF
##

Malformed elsif alternative in if statement.
The syntax of elsif alternatives is
    "elsif <expression> then <statements>"

stmt_command_start: IF ID THEN ELSIF ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 491.
##
## s_elsif -> ELSIF expr . THEN block [ END ELSIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSIF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing "then" in elsif alternative in if statement.
The syntax of elsif alternatives is
    "elsif <expression> then <statements>"


stmt_command_start: IF ID THEN ELSIF ID THEN WHERE
##
## Ends in an error in state: 492.
##
## s_elsif -> ELSIF expr THEN . block [ END ELSIF ELSE ]
##
## The known suffix of the stack is as follows:
## ELSIF expr THEN
##

Malformed elsif alternative in if statement.
The syntax of elsif alternatives is
    "elsif <expression> then <statements>"


stmt_command_start: IF ID THEN ELSIF ID THEN BEGIN END CATCH
##
## Ends in an error in state: 494.
##
## list(s_elsif) -> s_elsif . list(s_elsif) [ END ELSE ]
##
## The known suffix of the stack is as follows:
## s_elsif
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
## In state 493, spurious reduction of production s_elsif -> ELSIF expr THEN block
##

Malformed if statement.
The syntax of if statements is
    "if <expression> then <statements> else <statements> end"
or
    "if <expression> then <statements>
     elsif <expression> then <statements>
     ...
     else <statements>
     end"


stmt_command_start: IF ID THEN ELSE WHERE
##
## Ends in an error in state: 497.
##
## optional_else -> ELSE . block [ END ]
##
## The known suffix of the stack is as follows:
## ELSE
##

Malformed if statement.
The syntax of if statements is
    "if <expression> then <statements> else <statements> end"
or
    "if <expression> then <statements>
     elsif <expression> then <statements>
     ...
     else <statements>
     end"

stmt_command_start: IF ID THEN ELSE BEGIN END CATCH
##
## Ends in an error in state: 499.
##
## conditional_stmt -> IF expr THEN block list(s_elsif) optional_else . END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## IF expr THEN block list(s_elsif) optional_else
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
## In state 498, spurious reduction of production optional_else -> ELSE block
##

Malformed if statement.
The syntax of if statements is
    "if <expression> then <statements> else <statements> end"
or
    "if <expression> then <statements>
     elsif <expression> then <statements>
     ...
     else <statements>
     end"

stmt_command_start: REPEAT BEGIN END CATCH
##
## Ends in an error in state: 501.
##
## repetitive_stmt -> REPEAT block . UNTIL expr SEMICOLON pos [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## REPEAT block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Missing "until" in repeat-until statement.
The syntax of repeat-until statements is
    "repeat <statements> until <expression>;"

stmt_command_start: REPEAT UNTIL WHILE
##
## Ends in an error in state: 502.
##
## repetitive_stmt -> REPEAT block UNTIL . expr SEMICOLON pos [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## REPEAT block UNTIL
##

Malformed repeat-until statement.
The syntax of repeat-until statements is
    "repeat <statements> until <expression>;"


stmt_command_start: REPEAT UNTIL ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 503.
##
## repetitive_stmt -> REPEAT block UNTIL expr . SEMICOLON pos [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## REPEAT block UNTIL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";" in repeat-until statement.
The syntax of repeat-until statements is
    "repeat <statements> until <expression>;"

stmt_command_start: TRY BEGIN END ELSIF
##
## Ends in an error in state: 506.
##
## catch_stmt -> TRY block . CATCH pos list(catcher) opt_otherwise END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"


stmt_command_start: TRY CATCH WHILE
##
## Ends in an error in state: 508.
##
## catch_stmt -> TRY block CATCH pos . list(catcher) opt_otherwise END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY block CATCH pos
##

Malformed try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"


stmt_command_start: TRY CATCH WHEN WHILE
##
## Ends in an error in state: 509.
##
## catcher -> WHEN . ident COLON ident EQ_GT block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN
##

Missing variable identifier in try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"

stmt_command_start: TRY CATCH WHEN ID WHILE
##
## Ends in an error in state: 510.
##
## catcher -> WHEN ident . COLON ident EQ_GT block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN ident
##

Missing "=>" in try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"



stmt_command_start: TRY CATCH WHEN ID COLON WHILE
##
## Ends in an error in state: 511.
##
## catcher -> WHEN ident COLON . ident EQ_GT block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN ident COLON
##

Missing exception identifier in try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"


stmt_command_start: TRY CATCH WHEN ID COLON ID WHILE
##
## Ends in an error in state: 512.
##
## catcher -> WHEN ident COLON ident . EQ_GT block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN ident COLON ident
##

Missing "=>" in try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"

stmt_command_start: TRY CATCH WHEN ID COLON ID EQ_GT WHERE
##
## Ends in an error in state: 513.
##
## catcher -> WHEN ident COLON ident EQ_GT . block [ WHEN OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## WHEN ident COLON ident EQ_GT
##

Malformed catch alternative in try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"

stmt_command_start: TRY CATCH OTHERWISE EQ_GT BEGIN END CATCH
##
## Ends in an error in state: 516.
##
## catch_stmt -> TRY block CATCH pos list(catcher) opt_otherwise . END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY block CATCH pos list(catcher) opt_otherwise
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
## In state 482, spurious reduction of production opt_otherwise -> OTHERWISE EQ_GT block
##

Malformed try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"

stmt_command_start: TRY CATCH WHEN ID COLON ID EQ_GT BEGIN END CATCH
##
## Ends in an error in state: 518.
##
## list(catcher) -> catcher . list(catcher) [ OTHERWISE END ]
##
## The known suffix of the stack is as follows:
## catcher
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
## In state 514, spurious reduction of production catcher -> WHEN ident COLON ident EQ_GT block
##

Malformed try-catch statement.
The syntax of try-catch statements is
    "try
         <statements>
     catch
         when <variable identifier> : <exception identifier> => <statements>
         ...
         otherwise => <statements>
     end"

stmt_command_start: WHILE ID DO BEGIN END CATCH
##
## Ends in an error in state: 520.
##
## repetitive_stmt -> WHILE expr DO block . END [ WHILE WHEN VAR UNTIL TRY THROW RETURN REPEAT OTHERWISE MINUS LPAREN LET LBRACK IF ID FOR EOF END ELSIF ELSE CONSTANT CATCH CASE BEGIN ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed while statement.
The syntax of while statements is
    "while <expresssion> do <statements> end"

declarations_start: SETTER ID LBRACK RBRACK EQ ID COLON INTEGER BEGIN BEGIN END CATCH
##
## Ends in an error in state: 522.
##
## setter_declaration -> SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty BEGIN block . END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ ident COLON ty BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Missing "end" or malformed statement list.
The syntax of setter declarations is
    "setter $10$9[$7] = $4 : $2
     begin
         $0
     end"

declarations_start: SETTER ID EQ WHILE
##
## Ends in an error in state: 527.
##
## setter_declaration -> SETTER ident throws parameters_opt EQ . ident COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt EQ . ident COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt EQ
##

Malformed setter declaration.
The syntax of setter declarations is
    "setter $2$1 = <variable identifier> : <type> ..."


declarations_start: SETTER ID EQ ID WHILE
##
## Ends in an error in state: 528.
##
## setter_declaration -> SETTER ident throws parameters_opt EQ ident . COLON ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt EQ ident . COLON ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt EQ ident
##

Missing type annotation.
The syntax of setter declarations is
    "setter $3$2 = $0 : <type> ..."


declarations_start: SETTER ID EQ ID COLON WHILE
##
## Ends in an error in state: 529.
##
## setter_declaration -> SETTER ident throws parameters_opt EQ ident COLON . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt EQ ident COLON . ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt EQ ident COLON
##

Missing type.
The syntax of setter declarations is
    "setter $4$3 = $1 : <type> ..."


declarations_start: SETTER ID EQ ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 530.
##
## setter_declaration -> SETTER ident throws parameters_opt EQ ident COLON ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## setter_declaration -> SETTER ident throws parameters_opt EQ ident COLON ty . BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt EQ ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon or function body.
The syntax of setter declarations is
    "setter $4$3 = $2 : $0;"
or
    "setter $4$3 = $2 : $0
     begin
         ...
     end"

declarations_start: SETTER ID EQ ID COLON INTEGER BEGIN WHERE
##
## Ends in an error in state: 532.
##
## setter_declaration -> SETTER ident throws parameters_opt EQ ident COLON ty BEGIN . block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt EQ ident COLON ty BEGIN
##

Malformed setter declaration.
The syntax of setter declarations is
    "setter $6$5 = $3 : $1;"
or
    "setter $6$5 = $3 : $1
     begin
         ...
     end"

declarations_start: SETTER ID EQ ID COLON INTEGER BEGIN BEGIN END CATCH
##
## Ends in an error in state: 533.
##
## setter_declaration -> SETTER ident throws parameters_opt EQ ident COLON ty BEGIN block . END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## SETTER ident throws parameters_opt EQ ident COLON ty BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Missing "end" or malformed statement list.
The syntax of setter declarations is
    "setter $7$6 = $4 : $2
     begin
         $0
     end"

declarations_start: RECORD WHILE
##
## Ends in an error in state: 535.
##
## type_declaration -> RECORD . ident LBRACE nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> RECORD . ident ty_params LBRACE nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD
##

Missing record type name.
The syntax of record declarations is
    "record <type identifier> { <field> : <type>; ... };"
or
    "record <type identifier> (<parameter list>) { <field> : <type>; ... };"

declarations_start: RECORD ID WHILE
##
## Ends in an error in state: 536.
##
## type_declaration -> RECORD ident . LBRACE nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## type_declaration -> RECORD ident . ty_params LBRACE nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD ident
##

Malformed record declaration.
The syntax of record declarations is
    "record $0 { <field> : <type>; ... };"
or
    "record $0 (<parameter list>) { <field> : <type>; ... };"

declarations_start: RECORD ID LBRACE WHILE
##
## Ends in an error in state: 537.
##
## type_declaration -> RECORD ident LBRACE . nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD ident LBRACE
##

Record field expected.
The syntax of record declarations is
    "record $1 { <field> : <type>; ... };"
or
    "record $1 (<parameter list>) { <field> : <type>; ... };"

declarations_start: RECORD ID LBRACE ID COLON INTEGER SEMICOLON RBRACE WHILE
##
## Ends in an error in state: 539.
##
## type_declaration -> RECORD ident LBRACE nonempty_list(field) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD ident LBRACE nonempty_list(field) RBRACE
##

Missing ";".
The syntax of record declarations is
    "record $3 { $1 };"
or
    "record $3 (<parameter list>) { $1 };"


declarations_start: RECORD ID LBRACE ID WHILE
##
## Ends in an error in state: 541.
##
## field -> ident . COLON ty SEMICOLON [ RBRACE ID ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed field list.
The syntax of record field lists is
    "<field identifier> : <type>; ... <field identifier> : <type>;"

declarations_start: RECORD ID LBRACE ID COLON WHILE
##
## Ends in an error in state: 542.
##
## field -> ident COLON . ty SEMICOLON [ RBRACE ID ]
##
## The known suffix of the stack is as follows:
## ident COLON
##

Malformed field list.
The syntax of record field lists is
    "<field identifier> : <type>; ... <field identifier> : <type>;"

declarations_start: RECORD ID LBRACE ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 543.
##
## field -> ident COLON ty . SEMICOLON [ RBRACE ID ]
##
## The known suffix of the stack is as follows:
## ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon in field list.
The syntax of record field lists is
    "<field identifier> : <type>; ... <field identifier> : <type>;"


declarations_start: RECORD ID LBRACE ID COLON INTEGER SEMICOLON WHILE
##
## Ends in an error in state: 545.
##
## nonempty_list(field) -> field . [ RBRACE ]
## nonempty_list(field) -> field . nonempty_list(field) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field
##

Missing "}" or field in field list.
The syntax of record field lists is
    "<field identifier> : <type>; ... <field identifier> : <type>;"


declarations_start: RECORD ID LPAREN ID RPAREN WHILE
##
## Ends in an error in state: 547.
##
## type_declaration -> RECORD ident ty_params . LBRACE nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD ident ty_params
##

Malformed record declaration.
The syntax of record declarations is
    "record $1 { <field> : <type>; ... };"
or
    "record $1$0 { <field> : <type>; ... };"


declarations_start: RECORD ID LPAREN ID RPAREN LBRACE WHILE
##
## Ends in an error in state: 548.
##
## type_declaration -> RECORD ident ty_params LBRACE . nonempty_list(field) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD ident ty_params LBRACE
##

Malformed record declaration.
The syntax of record declarations is
    "record $2$1 { <field> : <type>; ... };"


declarations_start: RECORD ID LPAREN ID RPAREN LBRACE ID COLON INTEGER SEMICOLON RBRACE WHILE
##
## Ends in an error in state: 550.
##
## type_declaration -> RECORD ident ty_params LBRACE nonempty_list(field) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## RECORD ident ty_params LBRACE nonempty_list(field) RBRACE
##

Missing semicolon.
The syntax of record declarations is
    "record $4$3 { $1 };"

declarations_start: LET WHILE
##
## Ends in an error in state: 552.
##
## variable_declaration -> LET . ident ty_opt EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## LET
##

Malformed immutable variable declaration.
The syntax of immutable variable declarations is
    "let <variable identifier> = <expression>;"
or
    "let <variable identifier> : <type> = <expression>;"

declarations_start: LET ID WHILE
##
## Ends in an error in state: 553.
##
## variable_declaration -> LET ident . ty_opt EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## LET ident
##

Malformed immutable variable declaration.
The syntax of immutable variable declarations is
    "let $0 = <expression>;"
or
    "let $0 : <type> = <expression>;"

declarations_start: LET ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 554.
##
## variable_declaration -> LET ident ty_opt . EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## LET ident ty_opt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
## In state 271, spurious reduction of production ty_opt -> COLON ty
##

Missing variable initializer.
The syntax of immutable variable declarations is
    "let $1$0 = <expression>;"


declarations_start: LET ID EQ WHILE
##
## Ends in an error in state: 555.
##
## variable_declaration -> LET ident ty_opt EQ . expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## LET ident ty_opt EQ
##

Missing variable initializer.
The syntax of immutable variable declarations is
    "let $2$1 = <expression>;"


declarations_start: LET ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 556.
##
## variable_declaration -> LET ident ty_opt EQ expr . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## LET ident ty_opt EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing semicolon.
The syntax of immutable variable declarations is
    "let $3$2 = $0;"


declarations_start: GETTER WHILE
##
## Ends in an error in state: 558.
##
## getter_declaration -> GETTER . ident throws parameters_opt EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER . ident throws parameters_opt EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER . ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER . ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER
##

Missing name of getter function.
The syntax of getter declarations is
    "getter <getter identifier> => <type> ..."
or
    "getter <getter identifier>{ <parameters> } => <type> ..."
or
    "getter <getter identifier>[ <arguments> ] => <type> ..."
or
    "getter <getter identifier>{ <parameters> }[ <arguments> ] => <type> ..."

declarations_start: GETTER ID WHILE
##
## Ends in an error in state: 559.
##
## getter_declaration -> GETTER ident . throws parameters_opt EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident . throws parameters_opt EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident . throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident . throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident
##

Malformed getter function.
The syntax of getter declarations is
    "getter $0 => <type> ..."
or
    "getter $0{ <parameters> } => <type> ..."
or
    "getter $0[ <arguments> ] => <type> ..."
or
    "getter $0{ <parameters> }[ <arguments> ] => <type> ..."

declarations_start: GETTER ID LBRACE ID RBRACE WHILE
##
## Ends in an error in state: 561.
##
## getter_declaration -> GETTER ident throws parameters_opt . EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt . EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt . LBRACK formal_list RBRACK EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt . LBRACK formal_list RBRACK EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt
##

Malformed getter function.
The syntax of getter declarations is
    "getter $1$0 => <type> ..."
or
    "getter $1$0[ <arguments> ] => <type> ..."

declarations_start: GETTER ID LBRACK WHILE
##
## Ends in an error in state: 562.
##
## getter_declaration -> GETTER ident throws parameters_opt LBRACK . formal_list RBRACK EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt LBRACK . formal_list RBRACK EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt LBRACK
##


The syntax of getter declarations is
    "getter $2$1[ <arg1> : <type1>, ... ] => <type> ..."


declarations_start: GETTER ID LBRACK RBRACK WHILE
##
## Ends in an error in state: 564.
##
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK . EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK . EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt LBRACK formal_list RBRACK
##

Missing "=>"
The syntax of getter declarations is
    "getter $4$3[ $1 ] => <type> ..."

declarations_start: GETTER ID LBRACK RBRACK EQ_GT WHILE
##
## Ends in an error in state: 565.
##
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT . ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT
##

Missing return type.
The syntax of getter declarations is
    "getter $5$4[ $2 ] => <return type> ..."

declarations_start: GETTER ID LBRACK RBRACK EQ_GT INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 566.
##
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty . BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon or function body.
The syntax of getter declarations is
    "getter $6$5[ $3 ] => $0;"
or
    "getter $6$5[ $3 ] => $0 begin ... end"

declarations_start: GETTER ID LBRACK RBRACK EQ_GT INTEGER BEGIN WHERE
##
## Ends in an error in state: 568.
##
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty BEGIN . block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty BEGIN
##

Malformed getter declaration.
The syntax of getter declarations is
    "getter $7$6[ $4 ] => $1;"
or
    "getter $7$6[ $4 ] => $1 begin <statements> end"


declarations_start: GETTER ID LBRACK RBRACK EQ_GT INTEGER BEGIN BEGIN END CATCH
##
## Ends in an error in state: 569.
##
## getter_declaration -> GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty BEGIN block . END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt LBRACK formal_list RBRACK EQ_GT ty BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed getter declaration.
The syntax of getter declarations is
    "getter $8$7[ $5 ] => $2 begin
         $0
         <statements>
     end"


declarations_start: GETTER ID EQ_GT WHILE
##
## Ends in an error in state: 571.
##
## getter_declaration -> GETTER ident throws parameters_opt EQ_GT . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt EQ_GT . ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt EQ_GT
##

Missing return type.
The syntax of getter declarations is
    "getter $2$1 => <return type> ..."

declarations_start: GETTER ID EQ_GT INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 572.
##
## getter_declaration -> GETTER ident throws parameters_opt EQ_GT ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## getter_declaration -> GETTER ident throws parameters_opt EQ_GT ty . BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt EQ_GT ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing semicolon or function body.
The syntax of getter declarations is
    "getter $3$2 => $0;"
or
    "getter $3$2 => $0 begin ... end"


declarations_start: GETTER ID EQ_GT INTEGER BEGIN WHERE
##
## Ends in an error in state: 574.
##
## getter_declaration -> GETTER ident throws parameters_opt EQ_GT ty BEGIN . block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt EQ_GT ty BEGIN
##

Malformed getter declaration.
The syntax of getter declarations is
    "getter $4$3 => $1;"
or
    "getter $4$3 => $1 begin <statements> end"


declarations_start: GETTER ID EQ_GT INTEGER BEGIN BEGIN END CATCH
##
## Ends in an error in state: 575.
##
## getter_declaration -> GETTER ident throws parameters_opt EQ_GT ty BEGIN block . END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## GETTER ident throws parameters_opt EQ_GT ty BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed getter declaration.
The syntax of getter declarations is
    "getter $5$4 => $2 begin
         $0
         <statements>
     end"


declarations_start: FUNC WHILE
##
## Ends in an error in state: 577.
##
## function_declaration -> FUNC . ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC . ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC . ident throws parameters_opt LPAREN formals_with_default RPAREN SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC . ident throws parameters_opt LPAREN formals_with_default RPAREN BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC
##

Malformed function declaration.
The syntax of function declarations is
    "func <function identifier>(<arguments>) => <return type> ..."
or
    "func <function identifier>{<parameters>}(<arguments>) => <return type> ..."
or
    "func <function identifier>(<arguments>) ..."
or
    "func <function identifier>{<parameters>}(<arguments>) ..."

declarations_start: FUNC ID WHILE
##
## Ends in an error in state: 578.
##
## function_declaration -> FUNC ident . throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC ident . throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident . throws parameters_opt LPAREN formals_with_default RPAREN SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident . throws parameters_opt LPAREN formals_with_default RPAREN BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident
##

Malformed function declaration.
The syntax of function declarations is
    "func $0(<arguments>) => <return type> ..."
or
    "func $0{<parameters>}(<arguments>) => <return type> ..."
or
    "func $0(<arguments>) ..."
or
    "func $0{<parameters>}(<arguments>) ..."

declarations_start: FUNC ID LBRACE ID RBRACE WHILE
##
## Ends in an error in state: 580.
##
## function_declaration -> FUNC ident throws parameters_opt . LPAREN formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC ident throws parameters_opt . LPAREN formals_with_default RPAREN EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident throws parameters_opt . LPAREN formals_with_default RPAREN SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident throws parameters_opt . LPAREN formals_with_default RPAREN BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt
##

Malformed function declaration.
The syntax of function declarations is
    "func $1$0(<arguments>) => <return type> ..."
or
    "func $1$0(<arguments>) ..."

declarations_start: FUNC ID LPAREN WHILE
##
## Ends in an error in state: 581.
##
## function_declaration -> FUNC ident throws parameters_opt LPAREN . formals_with_default RPAREN EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC ident throws parameters_opt LPAREN . formals_with_default RPAREN EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident throws parameters_opt LPAREN . formals_with_default RPAREN SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident throws parameters_opt LPAREN . formals_with_default RPAREN BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN
##

Malformed function declaration.
The syntax of function declarations is
    "func $2$1(<arguments>) => <return type> ..."
or
    "func $2$1(<arguments>) ..."



declarations_start: FUNC ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 583.
##
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN . EQ_GT ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN . EQ_GT ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## procedure_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN . BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN
##

Missing "=>", ";" or function body.
The syntax of function declarations is
    "func $4$3($1) => <return type> ..."
or
    "func $4$3($1) ..."

declarations_start: FUNC ID LPAREN RPAREN EQ_GT WHILE
##
## Ends in an error in state: 585.
##
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT . ty SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT . ty BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT
##

Missing return type
The syntax of function declarations is
    "func $5$4($2) => <return type>;"
or
    "func $5$4($2) => <return type> begin <statements> end"


declarations_start: FUNC ID LPAREN RPAREN EQ_GT INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 586.
##
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty . BEGIN block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing ";" or "begin"
The syntax of function declarations is
    "func $6$5($3) => $0;"
or
    "func $6$5($3) => $0 begin <statements> end"

declarations_start: FUNC ID LPAREN RPAREN EQ_GT INTEGER BEGIN WHERE
##
## Ends in an error in state: 588.
##
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty BEGIN . block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty BEGIN
##

Malformed function body.
The syntax of function declarations is
    "func $7$6($4) => $1 begin
         <statements>
     end"

declarations_start: FUNC ID LPAREN RPAREN EQ_GT INTEGER BEGIN BEGIN END CATCH
##
## Ends in an error in state: 589.
##
## function_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty BEGIN block . END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN EQ_GT ty BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed function declaration.
The syntax of function declarations is
    "func $8$7($5) => $2 begin
         $0
         <statements>
     end"

declarations_start: FUNC ID LPAREN RPAREN BEGIN WHERE
##
## Ends in an error in state: 591.
##
## procedure_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN BEGIN . block END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN BEGIN
##

Malformed procedure body.
The syntax of procedure declarations is
    "func $5$4($2) begin
         <statements>
     end"

declarations_start: FUNC ID LPAREN RPAREN BEGIN BEGIN END CATCH
##
## Ends in an error in state: 592.
##
## procedure_declaration -> FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN BEGIN block . END [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## FUNC ident throws parameters_opt LPAREN formals_with_default RPAREN BEGIN block
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 472, spurious reduction of production block -> list(stmt)
##

Malformed procedure body.
The syntax of procedure declarations is
    "func $6$5($3) begin
         $0
         <statements>
     end"

declarations_start: ENUMERATION WHILE
##
## Ends in an error in state: 594.
##
## type_declaration -> ENUMERATION . ident LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## ENUMERATION
##

Missing enumeration type name.
The syntax of enumeration declarations is
    "enumeration <type identifier> { RED, GREEN, BLUE };"

declarations_start: ENUMERATION ID WHILE
##
## Ends in an error in state: 595.
##
## type_declaration -> ENUMERATION ident . LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## ENUMERATION ident
##

Missing list of enumeration constants.
The syntax of enumeration declarations is
    "enumeration $0 { RED, GREEN, BLUE };"


declarations_start: ENUMERATION ID LBRACE WHILE
##
## Ends in an error in state: 596.
##
## type_declaration -> ENUMERATION ident LBRACE . loption(separated_nonempty_list(COMMA,ident)) RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## ENUMERATION ident LBRACE
##

Missing list of enumeration constants.
The syntax of enumeration declarations is
    "enumeration $1 { RED, GREEN, BLUE };"

declarations_start: ENUMERATION ID LBRACE ID SEMICOLON
##
## Ends in an error in state: 597.
##
## type_declaration -> ENUMERATION ident LBRACE loption(separated_nonempty_list(COMMA,ident)) . RBRACE SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## ENUMERATION ident LBRACE loption(separated_nonempty_list(COMMA,ident))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 168, spurious reduction of production separated_nonempty_list(COMMA,ident) -> ident
## In state 313, spurious reduction of production loption(separated_nonempty_list(COMMA,ident)) -> separated_nonempty_list(COMMA,ident)
##

Missing "}" or malformed list of enumeration constants.
The syntax of enumeration declarations is
    "enumeration $2 { $0 };"


declarations_start: ENUMERATION ID LBRACE RBRACE WHILE
##
## Ends in an error in state: 598.
##
## type_declaration -> ENUMERATION ident LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## ENUMERATION ident LBRACE loption(separated_nonempty_list(COMMA,ident)) RBRACE
##

Missing ";".
The syntax of enumeration declarations is
    "enumeration $3 { $1 };"


declarations_start: CONSTANT WHILE
##
## Ends in an error in state: 600.
##
## variable_declaration -> CONSTANT . ident ty_opt EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONSTANT
##

Malformed constant declaration.
The syntax of constant declarations is
    "constant <variable identifier> = <expression>;"
or
    "constant <variable identifier> : <type> = <expression>;"

declarations_start: CONSTANT ID WHILE
##
## Ends in an error in state: 601.
##
## variable_declaration -> CONSTANT ident . ty_opt EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONSTANT ident
##

Malformed constant declaration.
The syntax of constant declarations is
    "constant $0 = <expression>;"
or
    "constant $0 : <type> = <expression>;"

declarations_start: CONSTANT ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 602.
##
## variable_declaration -> CONSTANT ident ty_opt . EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONSTANT ident ty_opt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
## In state 271, spurious reduction of production ty_opt -> COLON ty
##

Missing "=" in constant declaration.
The syntax of constant declarations is
    "constant $1$0 = <expression>;"

declarations_start: CONSTANT ID EQ WHILE
##
## Ends in an error in state: 603.
##
## variable_declaration -> CONSTANT ident ty_opt EQ . expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONSTANT ident ty_opt EQ
##

Malformed constant declaration.
The syntax of constant declarations is
    "constant $2$1 = <expression>;"

declarations_start: CONSTANT ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 604.
##
## variable_declaration -> CONSTANT ident ty_opt EQ expr . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONSTANT ident ty_opt EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";".
The syntax of constant declarations is
    "constant $3$2 = $0;"


declarations_start: CONFIG WHILE
##
## Ends in an error in state: 606.
##
## internal_definition -> CONFIG . ident COLON ty EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONFIG
##

Malformed configuration variable declaration.
The syntax of configuration variable declarations is
    "config <variable identifier> : <type> = <expression>;"

declarations_start: CONFIG ID WHILE
##
## Ends in an error in state: 607.
##
## internal_definition -> CONFIG ident . COLON ty EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONFIG ident
##

Malformed configuration variable declaration.
The syntax of configuration variable declarations is
    "config $0 : <type> = <expression>;"

declarations_start: CONFIG ID COLON WHILE
##
## Ends in an error in state: 608.
##
## internal_definition -> CONFIG ident COLON . ty EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONFIG ident COLON
##

Malformed configuration variable declaration.
The syntax of configuration variable declarations is
    "config $1 : <type> = <expression>;"

declarations_start: CONFIG ID COLON INTEGER UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 609.
##
## internal_definition -> CONFIG ident COLON ty . EQ expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONFIG ident COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production constraint_opt ->
## In state 219, spurious reduction of production ty -> INTEGER constraint_opt
##

Missing "=" in configuration variable declaration.
The syntax of configuration variable declarations is
    "config $2 : $0 = <expression>;"

declarations_start: CONFIG ID COLON INTEGER EQ WHILE
##
## Ends in an error in state: 610.
##
## internal_definition -> CONFIG ident COLON ty EQ . expr SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONFIG ident COLON ty EQ
##

Malformed configuration variable declaration.
The syntax of configuration variable declarations is
    "config $3 : $1 = <expression>;"

declarations_start: CONFIG ID COLON INTEGER EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 611.
##
## internal_definition -> CONFIG ident COLON ty EQ expr . SEMICOLON [ VAR UNDERSCORE_UNDERSCORE_OPERATOR_TWO UNDERSCORE_UNDERSCORE_OPERATOR_ONE UNDERSCORE_UNDERSCORE_BUILTIN TYPE SETTER RECORD LET GETTER FUNC EOF ENUMERATION CONSTANT CONFIG ]
##
## The known suffix of the stack is as follows:
## CONFIG ident COLON ty EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Missing ";".
The syntax of configuration variable declarations is
    "config $4 : $2 = $0;"

declarations_start: TYPE ID SEMICOLON WHILE
##
## Ends in an error in state: 624.
##
## list(declaration) -> declaration . list(declaration) [ EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##

Error at start of declaration.
If the previous declaration was a function, check that it has the right number of "end"s.

expr_command_start: WHILE
##
## Ends in an error in state: 626.
##
## expr_command_start' -> . expr_command_start [ # ]
##
## The known suffix of the stack is as follows:
##
##

Malformed expression.

expr_command_start: ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 628.
##
## expr_command_start -> expr_command . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr_command
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 630, spurious reduction of production expr_command -> expr
##

Malformed statement.

config_command_start: WHILE
##
## Ends in an error in state: 0.
##
## config_command_start' -> . config_command_start [ # ]
##
## The known suffix of the stack is as follows:
##
##

Malformed configuration command.1
The syntax of configuration commands is
    ":set config <ident> = <expr>"

config_command_start: ID WHILE
##
## Ends in an error in state: 2.
##
## config_command -> ident . EQ expr [ EOF ]
##
## The known suffix of the stack is as follows:
## ident
##

Malformed configuration command.
The syntax of configuration commands is
    ":set config <ident> = <expr>"

config_command_start: ID EQ WHILE
##
## Ends in an error in state: 3.
##
## config_command -> ident EQ . expr [ EOF ]
##
## The known suffix of the stack is as follows:
## ident EQ
##

Malformed configuration command.
The syntax of configuration commands is
    ":set config <ident> = <expr>"

config_command_start: ID EQ ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 236.
##
## config_command_start -> config_command . EOF [ # ]
##
## The known suffix of the stack is as follows:
## config_command
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
## In state 234, spurious reduction of production config_command -> ident EQ expr
##

Malformed configuration command.
The syntax of configuration commands is
    ":set config <ident> = <expr>"


stmt_command_start: WHERE
##
## Ends in an error in state: 631.
##
## stmt_command_start' -> . stmt_command_start [ # ]
##
## The known suffix of the stack is as follows:
##
##

Statement commands can only contain a single statement.

stmt_command_start: BEGIN END WHILE
##
## Ends in an error in state: 633.
##
## stmt_command_start -> stmt_command . EOF [ # ]
##
## The known suffix of the stack is as follows:
## stmt_command
##

Malformed statement command.

stmts_command_start: WHERE
##
## Ends in an error in state: 636.
##
## stmts_command_start' -> . stmts_command_start [ # ]
##
## The known suffix of the stack is as follows:
##
##

Malformed statement command.

stmts_command_start: BEGIN END WHEN
##
## Ends in an error in state: 638.
##
## stmts_command_start -> stmts_command . EOF [ # ]
##
## The known suffix of the stack is as follows:
## stmts_command
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 453, spurious reduction of production list(stmt) ->
## In state 456, spurious reduction of production list(stmt) -> stmt list(stmt)
## In state 640, spurious reduction of production stmts_command -> list(stmt)
##

Statement commands can only contain a single statement.

expr_command_start: UNDERSCORE_UNDERSCORE_ASSERT XOR
##
## Ends in an error in state: 14.
##
## conditional_expression -> UNDERSCORE_UNDERSCORE_ASSERT . expr UNDERSCORE_UNDERSCORE_IN expr [ UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON SEMICOLON RPAREN RBRACK RBRACE PLUS_COLON OF EQ_GT EOF ELSIF ELSE DOWNTO DOT_DOT DO COMMA COLON ]
##
## The known suffix of the stack is as follows:
## UNDERSCORE_UNDERSCORE_ASSERT
##

Malformed (unofficial extension) __assert expression.
The syntax of __assert expressions is
     "__assert <expr> __in <expr>"

expr_command_start: ID QUERY XOR
##
## Ends in an error in state: 33.
##
## aexpr -> ident QUERY . LPAREN loption(separated_nonempty_list(COMMA,arg)) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident QUERY
##

Malformed (unofficial extension) function call with exception marker.
The syntax of function calls with exception markers is
    "$1?(<argument list>)"

expr_command_start: ID QUERY LPAREN XOR
##
## Ends in an error in state: 34.
##
## aexpr -> ident QUERY LPAREN . loption(separated_nonempty_list(COMMA,arg)) RPAREN [ XOR UNDERSCORE_UNDERSCORE_IN TO THEN STAR_COLON STAR SLASH SEMICOLON RPAREN REM RBRACK RBRACE QUOT PLUS_PLUS PLUS_COLON PLUS OR OF MOD MINUS_MINUS_GT MINUS LT_MINUS_GT LT_LT LT_EQ LT LBRACK IN GT_GT GT_EQ GT EQ_GT EQ_EQ EOF ELSIF ELSE DOWNTO DOT_DOT DOT DO DIVRM DIV COMMA COLON CARET BAR_BAR BANG_EQ AS AND AMPERSAND_AMPERSAND ]
##
## The known suffix of the stack is as follows:
## ident QUERY LPAREN
##

Malformed (unofficial extension) function call with exception marker.
The syntax of function calls with exception markers is
    "$2?(<argument list>)"

expr_command_start: ARRAY LPAREN ID UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 119.
##
## separated_nonempty_list(COMMA,expr) -> expr . [ RPAREN ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production aexpr -> ident
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed (unofficial extension) array constructor.
The syntax of array constructors is
    "array(<expression list>)"

expr_command_start: ARRAY LPAREN ID COMMA XOR
##
## Ends in an error in state: 120.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Malformed (unofficial extension) array constructor.
The syntax of array constructors is
    "array(<expression list>)"

expr_command_start: ID LPAREN BITSLIT UNDERSCORE_UNDERSCORE_IN
##
## Ends in an error in state: 175.
##
## separated_nonempty_list(COMMA,arg) -> expr . [ RPAREN ]
## separated_nonempty_list(COMMA,arg) -> expr . COMMA separated_nonempty_list(COMMA,arg) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 90, spurious reduction of production fexpr -> aexpr
## In state 48, spurious reduction of production bexpr -> fexpr
## In state 58, spurious reduction of production list(factor) ->
## In state 85, spurious reduction of production cexpr -> bexpr list(factor)
## In state 57, spurious reduction of production conditional_expression -> cexpr
## In state 56, spurious reduction of production expr -> conditional_expression
##

Malformed function argument list.
The syntax of function arguments is a comma-separated list of either
    "<expr>"
or
    "<argument name> = <expr>"

expr_command_start: ID LPAREN ID EQ XOR
##
## Ends in an error in state: 178.
##
## separated_nonempty_list(COMMA,arg) -> ident EQ . expr [ RPAREN ]
## separated_nonempty_list(COMMA,arg) -> ident EQ . expr COMMA separated_nonempty_list(COMMA,arg) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## ident EQ
##

Malformed function argument.
The syntax of function arguments is either
    "<expr>"
or
    "<argument name> = <expr>"
